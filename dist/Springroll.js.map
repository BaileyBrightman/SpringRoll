{"version":3,"file":"Springroll.js","sources":["../src/debug/Debugger.js","../src/scale-manager/ScaleManager.js","../src/accessibility/SpeechSynth/SpeechSynth.js","../src/accessibility/ColorFilter/ColorFilter.js","../src/controller/Key.js","../src/controller/Controller.js","../node_modules/bellhop-iframe/dist/bellhop.js","../src/state/Property.js","../src/state/StateManager.js","../src/Application.js","../src/localization/captions/Caption.js","../src/localization/captions/TimedLine.js","../src/localization/captions/CaptionFactory.js","../src/localization/captions/CaptionPlayer.js","../src/localization/captions/renderers/IRenderer.js","../src/localization/captions/renderers/RendererDOM.js","../src/localization/captions/renderers/RendererTemplate.js","../src/localization/captions/renderers/RendererHTML.js","../src/localization/captions/renderers/RendererText.js","../src/localization/localizer/Localizer.js","../src/plugins/ApplicationPlugin.js"],"sourcesContent":["/**\n * @typedef {object} DebuggerParams\n * @property {boolean} emitEnabled\n * @property {boolean} enabled\n * @property {number} minLevel\n * @class Debugger\n * @param {Object} params - Options\n * @param {boolean} [params.emitEnabled=false] If this should emit events to the window.\n * @param {'GENERAL' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'} [params.minLevel='GENERAL'] The starting log level for the logger.\n */\nexport class Debugger {\n  /**\n   * Returns the params of the debugger.\n   * @returns {DebuggerParams}\n   * @readonly\n   * @static\n   * @memberof Debugger\n   */\n  static get params() {\n    Debugger.initParams();\n    return window[Debugger.paramKey];\n  }\n\n  /**\n   * Sets the logging level of the debugger.\n   * @param {string | number} level The name of the level.\n   * @return {void}\n   */\n  static minLevel(level) {\n    Debugger.initParams();\n    if ('number' === typeof level) {\n      window[Debugger.paramKey].minLevel = level;\n      return;\n    }\n\n    level = level.toUpperCase();\n    if (Debugger.isValidLevelName(level)) {\n      window[Debugger.paramKey].minLevel = Debugger.LEVEL[level];\n    } else {\n      window[Debugger.paramKey].minLevel = Debugger.LEVEL['GENERAL'];\n    }\n  }\n\n  /**\n   * Setup the params if not set already.\n   * @private\n   * @static\n   * @memberof Debugger\n   */\n  static initParams() {\n    if (!window[Debugger.paramKey]) {\n      window[Debugger.paramKey] = {\n        emitEnabled: false,\n        enabled: true,\n        minLevel: 1\n      };\n    }\n  }\n\n  /**\n   * If emitting is enabled for this instance, then it will dispatch an event on the window.\n   * @param {string} [eventName='Debugger'] Name of the event\n   */\n  static emit(eventName = 'Debugger') {\n    Debugger.initParams();\n    if (Debugger.params.emitEnabled) {\n      window.dispatchEvent(new Event(eventName));\n    }\n  }\n\n  /**\n   * Returns logging levels.\n   * @readonly\n   * @returns {object}\n   * @static\n   * @memberof Debugger\n   */\n  static get LEVEL() {\n    return {\n      GENERAL: 1,\n      DEBUG: 2,\n      INFO: 3,\n      WARN: 4,\n      ERROR: 5\n    };\n  }\n\n  /**\n   * Function to test if level meets requirements.\n   * @param {string} [level='GENERAL']\n   * @returns {boolean}\n   * @private\n   */\n  static meetsLevelRequirement(level = 'GENERAL') {\n    Debugger.initParams();\n    if (Debugger.isValidLevelName(level)) {\n      if (Debugger.LEVEL[level] >= Debugger.params.minLevel) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Console logs all supplied arguments if the log level is low enough for them to be logged.\n   * @param {'log' | 'general' | 'warn'| 'error' | 'debug' | 'info'} [type='log'] minimum level for this log to run at\n   * @param {*[]} args Arguments you wish to log.\n   */\n  static log(type = 'log', ...args) {\n    Debugger.initParams();\n    if (Debugger.isEnabled()) {\n      switch (type.toLowerCase()) {\n      case 'info':\n        if (Debugger.meetsLevelRequirement('INFO')) {\n          console.info(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'debug':\n        if (Debugger.meetsLevelRequirement('DEBUG')) {\n          console.debug(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'error':\n        if (Debugger.meetsLevelRequirement('ERROR')) {\n          console.error(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'warn':\n        if (Debugger.meetsLevelRequirement('WARN')) {\n          console.warn(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'log':\n      case 'general':\n      default:\n        if (Debugger.meetsLevelRequirement('GENERAL')) {\n          console.log(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Checks to see if the string argument is a valid level name.\n   * @param {string} level The level name.\n   * @return {boolean}\n   * @private\n   */\n  static isValidLevelName(level) {\n    Debugger.initParams();\n    if (\n      'GENERAL' == level ||\n      'DEBUG' == level ||\n      'INFO' == level ||\n      'WARN' == level ||\n      'ERROR' == level\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Will throw if statement is false.\n   * @static\n   * @param {boolean} isTrue The expression to evaluate.\n   */\n  static assert(isTrue) {\n    Debugger.initParams();\n    if (!isTrue) {\n      throw `Assert Error: ${isTrue}`;\n    }\n  }\n\n  /**\n   * Returns a boolean indicating if the debugger has been enabled or not.\n   * @static\n   * @returns {boolean}\n   */\n  static isEnabled() {\n    return window[Debugger.paramKey].enabled;\n  }\n\n  /**\n   * Disables or enables all debugger instances.\n   * @static\n   * @param {boolean} flag\n   * @returns {void}\n   */\n  static enable(flag) {\n    Debugger.initParams();\n    window[Debugger.paramKey].enabled = flag;\n  }\n\n  /**\n   * Returns the global params key.\n   * @readonly\n   * @static\n   * @memberof Debugger\n   */\n  static get paramKey() {\n    return '__spring_roll_debugger_params__';\n  }\n}\n","/**\n * Simplifies listening to resize events by passing the relevant data to a provided callback.\n * @class ScaleManager\n * @param {Function} [callback=undefined]\n * @property {Function} [callback=undefined]\n */\nexport class ScaleManager {\n  /**\n   *Creates an instance of ScaleManager.\n   */\n  constructor(callback = undefined) {\n    this.width = 1;\n    this.height = 1;\n    this.callback = undefined;\n\n    if (callback instanceof Function) {\n      this.enable(callback);\n    }\n\n    this.onResize = this.onResize.bind(this);\n  }\n\n  /**\n   * onResize maps and passes the relevant data to the user provided callback function.\n   * @param {UIEvent} event\n   * @private\n   */\n  onResize(event) {\n    const width = event.target.innerWidth;\n    const height = event.target.innerHeight;\n\n    this.callback({\n      width,\n      height,\n      ratio: width / height\n    });\n\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Enables the scale manager listener. Will not be enabled if a callback is not supplied.\n   * @param {Function} callback The function to be called on resize events.\n   */\n  enable(callback = undefined) {\n    if (callback instanceof Function) {\n      this.callback = callback;\n      window.addEventListener('resize', this.onResize);\n    } else {\n      console.warn('Scale Manager was not passed a function');\n    }\n  }\n\n  /**\n   * Disables the scale manager.\n   */\n  disable() {\n    window.removeEventListener('resize', this.onResize);\n  }\n}\n","/**\n * SpeechSync makes it easy to convert text to speech.\n * @class SpeechSynth\n * @param {object} params\n * @param {number} [params.voice=0] Indicates what voice to use.\n * @param {number} [params.rate=1] The rate at which the text is said. Supports a range from 0.1 to 10.\n * @param {number} [params.pitch=0] Voice Pitch. Supports a pitch from 0 to 2.\n * @param {number} [params.volume=1] Volume. Supports 0 to 1.\n * @property {boolean} voicesLoaded voices are loaded async. This is will be set to true when they are loaded.\n */\nexport class SpeechSynth {\n  /**\n   * Creates an instance of SpeechSynth.\n   */\n  constructor({ voice = 0, rate = 1, pitch = 0, volume = 1 } = {}) {\n    this.voiceOptions = [];\n    this.voicesLoaded = false;\n    this.queue = [];\n\n    this.options = {\n      voice: {},\n      rate,\n      pitch,\n      volume\n    };\n\n    /**\n     * Called when voices are ready to be used.\n     * @private\n     */\n    const loadVoices = function() {\n      this.voiceOptions = window.speechSynthesis.getVoices();\n      this.voice = this.setVoice(voice);\n      this.voicesLoaded = true;\n    }.bind(this);\n\n    const voiceOptions = window.speechSynthesis.getVoices();\n    if (Array.isArray(voiceOptions) && 0 < voiceOptions.length) {\n      loadVoices();\n    } else {\n      window.speechSynthesis.addEventListener('voiceschanged', loadVoices, {\n        once: true\n      });\n    }\n  }\n\n  /**\n   * Pauses the announcer.\n   */\n  pause() {\n    this.speaking = false;\n    window.speechSynthesis.pause();\n  }\n\n  /**\n   * Resumes the announcer.\n   */\n  resume() {\n    this.speaking = true;\n    window.speechSynthesis.resume();\n  }\n\n  /**\n   * Pauses the announcer and clears the queue.\n   */\n  cancel() {\n    this.speaking = false;\n    this.pause();\n    this.queue.length = 0;\n    window.speechSynthesis.cancel();\n  }\n\n  /**\n   * Causes the announcer to say whatever message is passed to it.\n   * If the announcer is already saying something then it will be added to a queue.\n   * @param {string} message\n   */\n  say(message) {\n    if (this.speaking || !this.voicesLoaded) {\n      this.queue.push(message);\n      return;\n    }\n\n    const onEnd = () => {\n      this.speaking = false;\n\n      if (0 < this.queue.length) {\n        this.say(this.queue.shift());\n      }\n    };\n\n    this.speaking = true;\n\n    const speaker = new SpeechSynthesisUtterance(message);\n\n    Object.assign(speaker, this.options);\n\n    speaker.onend = onEnd;\n\n    window.speechSynthesis.speak(speaker);\n  }\n\n  /**\n   * Helper function to control the range of values.\n   * Will return the min value if not a number.\n   * @private\n   * @param {number} min\n   * @param {number} max\n   * @param {number} value\n   * @returns {number}\n   */\n  rangeLimit(min, max, value) {\n    if (isNaN(value)) {\n      console.warn(`'${value}' is not a valid number!`);\n      return min;\n    }\n\n    if (value >= max) {\n      return max;\n    }\n\n    if (min >= value) {\n      return min;\n    }\n\n    return value;\n  }\n\n  /**\n   * Sets the voice by array index.\n   * @param {number} index\n   */\n  setVoice(index) {\n    this.options.voice = this.voiceOptions[index];\n  }\n\n  /**\n   * Returns the voice object.\n   * @returns {object | null}\n   */\n  getVoice() {\n    return this.options.voice;\n  }\n\n  /**\n   * Rate at which text is spoken.\n   * @param {number} rate\n   */\n  set rate(rate) {\n    this.options.rate = this.rangeLimit(0.1, 10, rate);\n  }\n\n  /**\n   * Returns rate which text is spoken.\n   * @returns {number}\n   */\n  get rate() {\n    return this.options.rate;\n  }\n\n  /**\n   * Sets the pitch at which text is spoken.\n   * @param {number} pitch\n   */\n  set pitch(pitch) {\n    this.options.pitch = this.rangeLimit(0, 2, pitch);\n  }\n\n  /**\n   * Returns the pitch at which text is spoken.\n   * @returns {number}\n   */\n  get pitch() {\n    return this.options.pitch;\n  }\n\n  /**\n   * Sets the current volume of the announcer.\n   * @param {number} volume\n   */\n  set volume(volume) {\n    this.options.volume = this.rangeLimit(0, 1, volume);\n  }\n\n  /**\n   * Returns the current volume of the announcer.\n   * @returns {number}\n   */\n  get volume() {\n    return this.options.volume;\n  }\n}\n","/**\n * The Color filter allows you to simulate colorblindness.\n * @export\n * @class ColorFilter\n */\nexport class ColorFilter {\n  /**\n   * Creates an instance of ColorFilter.\n   * @memberof ColorFilter\n   */\n  constructor() {\n    this.element = null;\n    if (null === document.getElementById('color__filter__svg')) {\n      document.head.innerHTML += `<svg\n      id=\"color__filter__svg\" xmlns=\"http://www.w3.org/2000/svg\"\n      version=\"1.1\">\n      <defs>\n        <filter id=\"color__filter__protanopia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.567, 0.433, 0,     0, 0\n                    0.558, 0.442, 0,     0, 0\n                    0,     0.242, 0.758, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__protanomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.817, 0.183, 0,     0, 0\n                    0.333, 0.667, 0,     0, 0\n                    0,     0.125, 0.875, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__deuteranopia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.625, 0.375, 0,   0, 0\n                    0.7,   0.3,   0,   0, 0\n                    0,     0.3,   0.7, 0, 0\n                    0,     0,     0,   1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__deuteranomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.8,   0.2,   0,     0, 0\n                    0.258, 0.742, 0,     0, 0\n                    0,     0.142, 0.858, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__tritanopia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.95, 0.05,  0,     0, 0\n                    0,    0.433, 0.567, 0, 0\n                    0,    0.475, 0.525, 0, 0\n                    0,    0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__tritanomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.967, 0.033, 0,     0, 0\n                    0,     0.733, 0.267, 0, 0\n                    0,     0.183, 0.817, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__achromatopsia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.299, 0.587, 0.114, 0, 0\n                    0.299, 0.587, 0.114, 0, 0\n                    0.299, 0.587, 0.114, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__achromatomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.618, 0.320, 0.062, 0, 0\n                    0.163, 0.775, 0.062, 0, 0\n                    0.163, 0.320, 0.516, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n      </defs>\n      </svg>\n      `;\n    }\n  }\n\n  /**\n   * Applies the specified filter to the element.\n   * @param {HTMLElement} element\n   * @param {string} type\n   * @memberof ColorFilter\n   */\n  applyFilter(element, type) {\n    this.element = element;\n    this.changeFilter(type);\n  }\n\n  /**\n   * Changes the currently applied filter to the element if the color filter has it.\n   * @param {string} type\n   * @returns\n   * @memberof ColorFilter\n   */\n  changeFilter(type) {\n    if (null !== this.element) {\n      this.element.style.filter = `url(#color__filter__${type})`;\n    }\n  }\n\n  /**\n   * Removes the filter from the element.\n   * @memberof ColorFilter\n   */\n  removeFilter() {\n    this.element.style.filter = null;\n  }\n\n  /**\n   * Supported filter types.\n   * @readonly\n   * @memberof ColorFilter\n\t * @returns { object } Returns an object { name, value } with the colorblindness type:\n\t * (Protanopia, Protanomaly, Deuteranopia, Deuteranomaly, Tritanopia, Tritanomaly, Achromatopsia, Achromatomaly)\n   */\n  get types() {\n    return [\n      {\n        name: 'Protanopia',\n        value: 'protanopia'\n      },\n      {\n        name: 'Protanomaly',\n        value: 'protanomaly'\n      },\n      {\n        name: 'Deuteranopia',\n        value: 'deuteranopia'\n      },\n      {\n        name: 'Deuteranomaly',\n        value: 'deuteranomaly'\n      },\n      {\n        name: 'Tritanopia',\n        value: 'tritanopia'\n      },\n      {\n        name: 'Tritanomaly',\n        value: 'tritanomaly'\n      },\n      {\n        name: 'Achromatopsia',\n        value: 'achromatopsia'\n      },\n      {\n        name: 'Achromatomaly',\n        value: 'achromatomaly'\n      }\n    ];\n  }\n}\n","/**\n * Represents a single key on the keyboard and the functions related to it.\n * @class Key\n * @property {0 | 1 | 2} state The current state of the key. 0 = inactive, 1 = active, 2 = to be set to inactive.\n * @property {string} key The name of the key we are targeting.\n * @property {object} actions\n * @property {function} actions.down Function to be called while the key is held down.\n * @property {function} actions.up Function to be called when the key is lifted up.\n * @param {string} key What this object represents.\n * @param {function} [down=() => {}] Function to be called while the key is held down.\n * @param {function} [up=() => {}] Function to be called when the key is lifted up.\n */\nexport class Key {\n  /**\n   * Creates an instance of Key.\n   */\n  constructor(key, down = () => {}, up = () => {}) {\n    this.key = key;\n    this._state = 0;\n    this.actions = {\n      up,\n      down\n    };\n  }\n\n  /**\n   *\n   * Updates the internal state of the key. Accepts a range between 0-2. Will set key state to 0 if nothing is passed.\n   * @param {0 | 1 | 2} [state=0]\n   * @memberof Key\n   */\n  updateState(state = 0) {\n    if (state < 3 && state > -1) {\n      this._state = state;\n    }\n  }\n\n  /**\n   * Calls the relevant action for the current state of the key.\n   * @memberof Key\n   */\n  action() {\n    if (1 === this.state) {\n      this.actions.down();\n    } else if (2 === this.state) {\n      this.actions.up();\n      this.updateState(0);\n    }\n  }\n\n  /**\n   *\n   * Returns the current state of the key.\n   * @readonly\n   * @returns { number }\n   * @memberof Key\n   */\n  get state() {\n    return this._state;\n  }\n}\n","import { Key } from './Key';\n/**\n * Controller interface class to simplify working with key presses.\n * @export\n * @class Controller\n * @param {Array} [buttons=[]] An object containing all keys you want to watch and their functions. e.g. {enter: () => {}}. See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for potential values.\n */\nexport class Controller {\n  /**\n   * Creates an instance of Controller.\n   * @memberof Controller\n   */\n  constructor(buttons = []) {\n    this.assignButtons(buttons);\n\n    window.addEventListener('keydown', this.onKeyDown.bind(this));\n    window.addEventListener('keyup', this.onKeyUp.bind(this));\n  }\n\n  /**\n   * Calls all functions for buttons that are currently set to enabled.\n   * @memberof Controller\n   */\n  update() {\n    for (let i = 0, l = this.keys.length; i < l; i++) {\n      this.buttons[this.keys[i]].action();\n    }\n  }\n\n  /**\n   * Called on keyup. Sets flag to 1 if key is being watched.\n   * @param {KeyboardEvent} e\n   * @memberof Controller\n   */\n  onKeyDown(e) {\n    this.onKey(e, 1);\n  }\n\n  /**\n   * Called on keyup. Sets flag to 2 if key is being watched.\n   * @param {KeyboardEvent} e\n   * @memberof Controller\n   */\n  onKeyUp(e) {\n    this.onKey(e, 2);\n  }\n\n  /**\n   * Sets an object of button functions to the controller to be called.\n   * @param {Array} buttons\n   * @memberof Controller\n   */\n  assignButtons(buttons) {\n    this.buttons = {};\n    this.keys = [];\n    for (let i = 0, l = buttons.length; i < l; i++) {\n      this.keys.push(buttons[i].key);\n      this.buttons[buttons[i].key] = new Key(\n        buttons[i].key,\n        buttons[i].down,\n        buttons[i].up\n      );\n    }\n  }\n\n  /**\n   * Helper class to reduce code between event functions.\n   * @private\n   * @param {KeyboardEvent} event\n   * @param {0 | 1 | 2} state\n   * @memberof Controller\n   */\n  onKey(event, state) {\n    const key = event.key.toLowerCase();\n    if (this.buttons[key]) {\n      this.buttons[key].updateState(state);\n    }\n  }\n}\n","/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nclass BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {Function} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} type The type of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(type, callback) {\n    if (this._listeners[type] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[type];\n      return;\n    }\n\n    const index = this._listeners[type].indexOf(callback);\n\n    -1 < index ? this._listeners[type].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {Object | String} event The event to send\n   */\n  trigger(event) {\n    if (typeof event == 'string') {\n      event = {\n        type: event\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nclass Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {Boolean} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {DOMElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      // Ignore all other message if we don't have a context\n      if (\n        this.connected &&\n        'object' === typeof message.data &&\n        message.data.type\n      ) {\n        this.trigger(message.data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0, length = this._sendLater.length; i < length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive.bind(this));\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(message, this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object} data The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n\nexport { BellhopEventDispatcher, Bellhop };\n//# sourceMappingURL=bellhop.js.map\n","/**\n * A class for representing changeable/subscribable properties.\n * @class Property\n */\nexport default class Property {\n  /**\n   * Creates a new property with an initial value.\n   * @param Any initialValue The initial value of this property.\n   */\n  constructor(initialValue) {\n    this._value = initialValue;\n    this.listeners = [];\n\n    Object.defineProperty(this, 'value', {\n      get: () => this._value,\n      set: (value) => {\n        this._value = value;\n        this.notifyChange();\n      }\n    });\n  }\n\n  /**\n   * Notifies all subscribers to the property of a new value.\n   */\n  notifyChange() {\n    this.listeners.forEach(listener => {\n      listener(this.value);\n    });\n  }\n\n  /**\n   * Adds a subscriber to this property.\n   * @param Function callback The callback to call whenever the property changes.\n   */\n  subscribe(callback) {\n    this.listeners.push(callback);\n  }\n\n  /**\n   * Unsubscribes a listener from this property.\n   * @param Function callback The callback to unsubscribe.\n   */\n  unsubscribe(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  /**\n   * Whether or not this property has any subscribed listeners\n   * @return Boolean True if this property has at least one subscriber\n   */\n  get hasListeners() {\n    return this.listeners.length > 0;\n  }\n}\n","import Property from './Property.js';\n\n/**\n * A class for managing a group of subscribable properties together. Allows for the registration of new properties.\n * @class StateManager\n * For example:\n * var manager = new StateManager();\n * manager.addField('paused', false);\n * manager.paused.subscribe(function(newValue) {\n *   console.log('New value is ', newValue);\n * })\n *\n * manager.paused = true;\n * @class StateManager\n */\nexport default class StateManager {\n  /**\n   * Adds a new subscribable field field to the state manager. Throws an error if the field already exists.\n   * @param {String} name The name of the field.\n   * @param {Any} initialValue The initial value of the property.\n   * @return Property The newly created property.\n   */\n  addField(name, initialValue) {\n    if ('undefined' !== typeof this[name]) {\n      throw new Error('\"' + name + '\" is already a registered property');\n    }\n\n    this[name] = new Property(initialValue);\n    return this[name];\n  }\n}\n","import { Bellhop } from 'bellhop-iframe';\nimport { Debugger } from './debug/Debugger.js';\nimport StateManager from './state/StateManager.js';\n\n/**\n * Main entry point for a game. Provides a single focal point for plugins and functionality to attach.\n * @class Application\n */\nexport class Application {\n  /**\n   * Creates a new application, setting up plugins along the way.\n   * @param {Object} features A configuration object denoting which features are enabled for this application\n   * @param {Boolean} features.captions A boolean value denoting that this game supports captions\n   * @param {Boolean} features.sound A boolean value denoting that this game has some audio in it\n   * @param {Boolean} features.vo A boolean denoting that this game has mutable voice-over audio in it\n   * @param {Boolean} features.music A boolean denoting that this game has mutable music in it\n   * @param {Boolean} features.sfxButton A boolean denoting that this game has mutable sound effects in it\n   */\n  constructor(features = {}) {\n    /**\n     * @member {StateManager} The state manager for this application instance. Maintains subscribable properties for\n     *                        whether or not audio is muted, captions are displayed, or the game is paused.\n     */\n    this.state = new StateManager();\n    this.state.addField('ready', false);\n    this.state.addField('soundMuted', false);\n    this.state.addField('captionsMuted', true);\n    this.state.addField('musicMuted', false);\n    this.state.addField('voMuted', false);\n    this.state.addField('sfxMuted', false);\n    this.state.addField('pause', false);\n    this.state.addField('playOptions', {});\n\n    this.features = Object.assign(\n      {\n        captions: false,\n        sound: false,\n        vo: false,\n        music: false,\n        sfxButton: false\n      },\n      features\n    );\n\n    // always enable sound if one of the sound channels is enabled\n    if (this.features.vo || this.features.music || this.features.sfxButton) {\n      this.features.sound = true;\n    }\n\n    // create the connection to the container (if possible), and report features and SpringRoll 1 compat data\n    this.container = new Bellhop();\n    this.container.connect();\n    this.container.send('features', this.features);\n    this.container.send('keepFocus', false);\n\n    // listen for events from the container and keep the local value in sync\n    [\n      'soundMuted',\n      'captionsMuted',\n      'musicMuted',\n      'voMuted',\n      'sfxMuted',\n      'pause'\n    ].forEach(eventName => {\n      const property = this.state[eventName];\n      this.container.on(\n        eventName,\n        containerEvent => (property.value = containerEvent.data)\n      );\n    });\n\n    // maintain focus sync between the container and application\n    window.addEventListener('focus', () => this.container.send('focus', true));\n    window.addEventListener('blur', () => this.container.send('focus', false));\n\n    // attempt to fetch play options from the query string (passed by the Container)\n    const match = /playOptions=[^&$]*/.exec(window.location.search);\n    if (match !== null) {\n      const matchedToken = match[0];\n      const rawValue = decodeURIComponent(matchedToken.split('=')[1]);\n\n      try {\n        this.playOptions = JSON.parse(rawValue);\n      } catch (e) {\n        Debugger.log(\n          'warn',\n          'Failed to parse playOptions from query string:' + e.message\n        );\n      }\n    }\n\n    // Also attempt to fetch over the iframe barrier for old container support\n    this.container.fetch('playOptions', e => (this.playOptions.value = e.data));\n\n    Application._plugins.forEach(plugin => plugin.setup.call(this));\n\n    const preloads = Application._plugins.map(plugin =>\n      this.promisify(plugin.preload)\n    );\n    Promise.all(preloads)\n      .catch(e => {\n        console.warn(e);\n      })\n      .then(() => {\n        this.validateListeners();\n      })\n      .catch(e => {\n        console.warn(e);\n      })\n      .then(() => {\n        this.container.send('loaded');\n        this.state.ready.value = true;\n      });\n  }\n\n  /**\n   * Converts a callback-based or synchronous function into a promise. This method is used for massaging plugin preload\n   * methods before they are executed.\n   * @param {Function} callback A function that takes either a callback, or returns a promise.\n   * @return Promise A promise that resolves when the function finishes executing (whether it is asynchronous or not).\n   */\n  promisify(callback) {\n    // if it takes no argument, assume that it's synchronous or returns a Promise.\n    if (callback.length === 0) {\n      return Promise.resolve(callback.call(this));\n    }\n\n    // If it has an argument, that means it uses a callback structure.\n    return new Promise((resolve, reject) => {\n      callback.call(this, function(error) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(error);\n        }\n      });\n    });\n  }\n\n  /**\n   * Validates that appropriate listeners are added for the features that were enabled in the constructor\n   * @throws Error\n   */\n  validateListeners() {\n    const missingListeners = [];\n\n    const featureToStateMap = {\n      captions: 'captionsMuted',\n      sound: 'soundMuted',\n      music: 'musicMuted',\n      vo: 'voMuted',\n      sfxButton: 'sfxMuted'\n    };\n\n    Object.keys(featureToStateMap).forEach(feature => {\n      const stateName = featureToStateMap[feature];\n\n      if (this.features[feature] && !this.state[stateName].hasListeners) {\n        missingListeners.push(stateName);\n      }\n    });\n\n    if (!this.state.pause.hasListeners) {\n      missingListeners.push('pause');\n    }\n\n    if (missingListeners.length) {\n      throw new Error(\n        'Application state is missing required listeners: ' +\n          missingListeners.join(', ') +\n          '.'\n      );\n    }\n  }\n}\n\n/**\n * The list of plugins that are currently registered to run on Applications.\n * @static\n */\nApplication._plugins = [];\n\n/**\n * Registers a plugin to be used by applications, sorting it by priority order.\n * @param {ApplicationPlugin} plugin The plugin to register.\n */\nApplication.uses = function(plugin) {\n  Application._plugins.push(plugin);\n  Application._plugins.sort((p1, p2) => p2.priority - p1.priority);\n};\n","/**\n * @export\n * @class Caption\n */\nexport class Caption {\n  /**\n   * Creates an instance of Caption.\n   * @param {TimedLine[]} lines - Array of lines to be used for caption.\n   * @memberof Caption\n   */\n  constructor(lines) {\n    this.lines = lines;\n\n    // Sort by end time, this ensures proper execution order of lines.\n    this.lines.sort(function(a, b) {\n      if (a.endTime < b.endTime) {\n        return -1;\n      }\n\n      if (a.endTime > b.endTime) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    this.reset();\n  }\n\n  /**\n   * Resets time, lineIndex and content fields.\n   * @private\n   * @memberof Caption\n   */\n  reset() {\n    this.time = 0;\n    this.lineIndex = 0;\n    this.renderer = null;\n  }\n\n  /**\n   * Updates content based on time passed.\n   * This ~should~ be called every frame that the caption is active.\n   *\n   * @param {Number} deltaTime - Time in seconds since last frame.\n   * @memberof Caption\n   */\n  update(deltaTime) {\n    const time = this.time + deltaTime * 1000;\n    if (time === this.time) {\n      return;\n    }\n\n    this.updateState(time, this.time);\n    this.time = time;\n  }\n\n  /**\n   * Handles calling callbacks and updating caption's current state.\n   * @param  {Number} currentTime\n   * @param  {Number} lastTime\n   * @memberof Caption\n   */\n  updateState(currentTime, lastTime) {\n    if (this.isFinished()) {\n      return;\n    }\n\n    if (currentTime > this.lines[this.lineIndex].endTime) {\n      this.renderer.lineEnd();\n    }\n\n    while (currentTime > this.lines[this.lineIndex].endTime) {\n      this.lineIndex++;\n      if (this.isFinished()) {\n        return;\n      }\n    }\n\n    const line = this.lines[this.lineIndex];\n    if (currentTime >= line.startTime && lastTime < line.startTime) {\n      this.renderer.lineBegin(line);\n      return;\n    }\n  }\n\n  /**\n   * Checks if caption has completed.\n   * @returns {Boolean}\n   * @memberof Caption\n   */\n  isFinished() {\n    return this.lineIndex >= this.lines.length;\n  }\n\n  /**\n   * Sets time and line index of caption.\n   *\n   * @param {Number} [time=0] - Time in milliseconds.\n   * @memberof Caption\n   */\n  start(time = 0, renderer = { lineBegin: () => {}, lineEnd: () => {} }) {\n    this.reset();\n    this.renderer = renderer;\n    this.time = time;\n\n    // Initialize to the correct line index\n    while (this.time > this.lines[this.lineIndex].endTime) {\n      this.lineIndex++;\n      if (this.isFinished()) {\n        return;\n      }\n    }\n    this.updateState(this.time, this.time - 1);\n  }\n}\n","/**\n * @export\n * @class TimedLine\n */\nexport class TimedLine {\n  /**\n   * Creates an instance of TimedLine.\n   * @param {Number} startTime - Start time in milliseconds relative to caption.\n   * @param {Number} endTime - End time in milliseconds relative to caption.\n   * @param {string} content - HMTL formatted string content to show during time-span.\n   * @memberof TimedLine\n   */\n  constructor(startTime, endTime, content) {\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.setContent(content);\n  }\n\n  /**\n   * Sets line's content. Removes HTML formatting for text.\n   * @param  {any} content\n   * @return {void}@memberof TimedLine\n   */\n  setContent(content) {\n    this.content = content;\n    this.text = content.replace(/(<([^>]+)>)/gi, '');\n  }\n}\n","import { Debugger } from './../../debug/Debugger';\nimport { Caption } from './Caption';\nimport { TimedLine } from './TimedLine';\n\n/**\n * Collection of functions for creating Captions\n *\n * @export\n * @class CaptionFactory\n */\nexport class CaptionFactory {\n  /**\n   * Creates a new Object<String, Caption>.\n   *\n   * @static\n   * @param {JSON} data\n   * @returns {Object}\n   * @memberof CaptionFactory\n   */\n  static createCaptionMap(data) {\n    const captions = {};\n    for (const key in data) {\n      const caption = this.createCaption(data[key]);\n      if (!caption) {\n        Debugger.log(\n          'error',\n          '[CaptionFactory.createCaptionMap] failed to create caption:',\n          key\n        );\n      } else {\n        captions[key] = caption;\n      }\n    }\n    return captions;\n  }\n\n  /**\n   * Creates a new Caption from JSON data.\n   *\n   * @static\n   * @param {*} captionData\n   * @returns {Caption} new Caption\n   * @memberof CaptionFactory\n   */\n  static createCaption(captionData) {\n    const lines = [];\n    for (let i = 0, length = captionData.length; i < length; i++) {\n      const line = this.createLine(captionData[i]);\n      if (line) {\n        lines.push(line);\n      }\n    }\n\n    if (lines.length <= 0) {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createCaption] captions should not have 0 lines.'\n      );\n      return;\n    }\n\n    return new Caption(lines);\n  }\n\n  /**\n   * Creates a new TimedLine from JSON data.\n   *\n   * @static\n   * @param {*} lineData\n   * @returns {TimedLine} new TimedLine;\n   * @memberof CaptionFactory\n   */\n  static createLine(lineData) {\n    if (typeof lineData.start !== 'number') {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createLine] lineData.start must be defined as a number'\n      );\n      return;\n    }\n\n    if (typeof lineData.end !== 'number') {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createLine] lineData.end must be defined as a number'\n      );\n      return;\n    }\n\n    if (typeof lineData.content !== 'string') {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createLine] lineData.content must be defined as a string'\n      );\n      return;\n    }\n\n    if (lineData.content === '') {\n      Debugger.log(\n        'warn',\n        '[CaptionFactory.createLine] lineData.content should not be empty',\n        'Its recommended to add time to the start of the next line to add delays.'\n      );\n      return;\n    }\n\n    //TODO: any future formatting changes should go here.\n    return new TimedLine(lineData.start, lineData.end, lineData.content);\n  }\n}\n","import { Debugger } from '../../debug/Debugger';\nimport { CaptionFactory } from './CaptionFactory';\n\n/**\n *  CaptionPlayer is used to start, stop and update captions.\n *  It applies the content of an active caption to a given CaptionRenderer.\n *\n * @export\n * @class CaptionPlayer\n/*\n *\n * @export\n * @class CaptionPlayer\n */\nexport class CaptionPlayer {\n  /**\n   * Creates an instance of CaptionPlayer.\n   * @param {*} captions - Captions map.\n   * @param {IRender} renderer CaptionRenderer that content is applied to.\n   * @memberof CaptionPlayer\n   */\n  constructor(captions, renderer) {\n    this.captions = CaptionFactory.createCaptionMap(captions);\n\n    this.renderer = renderer;\n\n    this.activeCaption = null;\n  }\n\n  /**\n   * Updates any currently playing caption.\n   * This ~should~ be called every frame.\n   *\n   * @param {Number} deltaTime Time passed in seconds since last update call.\n   * @memberof CaptionPlayer\n   */\n  update(deltaTime) {\n    if (this.activeCaption) {\n      this.activeCaption.update(deltaTime);\n      if (this.activeCaption.isFinished()) {\n        this.stop();\n      }\n    }\n  }\n\n  /**\n   * Starts playing a caption.\n   *\n   * @param {String} name Name of caption.\n   * @param {number} [time=0] Atart time in milliseconds.\n   * @param {object} [args = {}] Arguments that will get passed to the renderer\n   * @memberof CaptionPlayer\n   */\n  start(name, time = 0, args = {}) {\n    this.stop();\n    this.activeCaption = this.captions[name];\n    if (this.activeCaption) {\n      this.renderer.start(args);\n      this.activeCaption.start(time, this.renderer);\n      return;\n    }\n\n    Debugger.log('warn', `[CaptionPlayer.Start()] caption ${name} not found`);\n  }\n\n  /**\n   * Stops any caption currently playing.\n   * @memberof CaptionPlayer\n   */\n  stop() {\n    if (this.activeCaption) {\n      if (this.renderer.stop) {\n        this.renderer.stop();\n      }\n    }\n    this.activeCaption = null;\n  }\n}\n","/**\n * Render interface to help enforce minimum requirements for caption renderers\n * @interface\n * @class IRender\n * @property {function} start called when the Caption Player starts playing captions\n * @property {function} stop called when the Caption Player stops playing captions\n * @property {function} lineBegin called when rendering a new line of text\n * @property {function} lineEnd called when finished rendering a new of text\n */\nexport class IRender {\n  /**\n   *Creates an instance of Renderer.\n   * @memberof Renderer\n   */\n  constructor() {\n    if (\n      'function' !== typeof this.start ||\n      'function' !== typeof this.stop ||\n      'function' !== typeof this.lineBegin ||\n      'function' !== typeof this.lineEnd\n    ) {\n      console.error(\n        'Springroll Caption Renderer not implemented corrected. Please ensure you have a \"start\", \"end\", \"lineBegin\", and \"lineEnd\" function in your class.'\n      );\n    }\n  }\n}\n","import { IRender } from './IRenderer';\n/**\n *\n * DOMRender is a incomplete renderer that is intended to supply just the basic start and stop functions\n * @export\n * @class DOMRenderer\n * @param {HTMLElement} element\n * @param {Object} templateVariables\n */\nexport class DOMRenderer extends IRender {\n  /**\n   *Creates an instance of DOMRenderer.\n   * @memberof DOMRenderer\n   */\n  constructor(element, templateVariables = {}) {\n    super();\n\n    if (!(element instanceof HTMLElement)) {\n      console.error('Invalid html element provided to renderer');\n    }\n\n    this.renderTarget = element;\n    this.templateVariables = templateVariables;\n  }\n  /**\n   * Makes target element visible and ready to present captions\n   * @param {object} [templateVariables = {}] Variables that can used during caption play time\n   * @memberof DOMRenderer\n   */\n  start(templateVariables = {}) {\n    this.renderTarget.style.visibility = 'visible';\n    this.templateVariables = templateVariables;\n  }\n\n  /**\n   *\n   * H\n   * @memberof DOMRenderer\n   */\n  stop() {\n    this.renderTarget.style.visibility = 'hidden';\n    this.templateVariables = {};\n  }\n}\n","/**\n * TemplateRenderer accepts a string template e.g.`The ball is {{color}}` and a args object e.g. `{color: 'red'}`\n * and swaps out the placeholder inside the double brackets with the matching key inside the args object\n * @export\n * @param {string} template String template that will be rendered with the supplied arguments\n * @param {Object} args //An Object contain data to be inserted into the template This will match based on key values\n * @returns {string}\n */\nexport function TemplateRenderer(template, args) {\n  return template.replace(\n    /{{([a-zA-Z][A-Za-z0-9]*)}}/g,\n    (_, key) => args[key] || _\n  );\n}\n","import { DOMRenderer } from './RendererDOM';\nimport { TemplateRenderer } from './RendererTemplate';\n/**\n *\n * HTML Renderer is intended for rendering raw html in the use case of wanting to display styled captions\n * @export\n * @class HtmlRenderer\n * @implements {RendererInterface}\n */\nexport class HtmlRenderer extends DOMRenderer {\n  /**\n   *\n   * Called by Caption Player when a new line needs to be displayed\n   * @memberof HtmlRenderer\n   */\n  lineBegin(line) {\n    this.renderTarget.innerHTML = TemplateRenderer(\n      line.content,\n      this.templateVariables\n    );\n  }\n\n  /**\n   *\n   * Called by Caption Player when a line is complete\n   * @memberof HtmlRenderer\n   */\n  lineEnd() {\n    this.renderTarget.innerHTML = '';\n  }\n}\n","import { TemplateRenderer } from './RendererTemplate';\nimport { DOMRenderer } from './RendererDOM';\n/**\n *\n * TextRenderer is intended for just rendering test. It will attempt to sanitize any strings passed to it by removing html syntax\n * @export\n * @class TextRenderer\n * @implements {RendererInterface}\n */\nexport class TextRenderer extends DOMRenderer {\n  /**\n   *\n   * Called by Caption Player when a new line needs to be displayed\n   * @memberof TextRenderer\n   */\n  lineBegin(line) {\n    this.renderTarget.innerText = this.sanitize(\n      TemplateRenderer(line.content, this.templateVariables)\n    );\n  }\n\n  /**\n   *\n   * Called by Caption Player when a line is complete\n   * @memberof TextRenderer\n   */\n  lineEnd() {\n    this.renderTarget.textContent = '';\n  }\n\n  /**\n   *\n   * Will attempt to remove all html from a string before it's renderer to the page\n   * @param {*} html\n   * @memberof TextRenderer\n   */\n  sanitize(html) {\n    const div = document.createElement('div');\n    div.innerHTML = html;\n    return div.textContent || div.innerText || '';\n  }\n}\n","/**\n * @typedef {{path: string}} Locale\n * @typedef {{default: string, locales: { name: Locale }} Localizer.Config\n * @typedef {{language: string, fallback: string}} Localizer.Options\n */\n\n/**\n * @export\n * @class Localizer\n */\nexport class Localizer {\n  /**\n   * Creates an instance of Localizer.\n   * @param {Localizer.Config} Config\n   * @param {Localizer.Options} Options\n   * @memberof Localizer\n   */\n  constructor(config, options = {}) {\n    this.locales = config.locales;\n\n    this.setPrimaryLocale(\n      options.language || this.getBrowsersLocaleKey() || config.default\n    );\n    this.setFallbackLocale(options.fallback || config.default);\n  }\n\n  /**\n   *\n   * @param  {string} Path\n   * @param  {any} [options={}]\n   * @return {Promise}\n   * @memberof Localizer\n   */\n  resolve(path, options = {}) {\n    const language = options.language\n      ? this.getLocaleKey(options.language)\n      : this.primaryLanguage;\n    const fallback =\n      this.getLocaleKey(options.fallback) || this.fallbackLanguage;\n\n    const primaryLocale = this.locales[language];\n    const fallbackLocale = this.locales[fallback];\n\n    if (primaryLocale) {\n      return { path: primaryLocale.path + path, language: language };\n    }\n\n    if (fallbackLocale) {\n      return { path: fallbackLocale.path + path, language: fallback };\n    }\n  }\n\n  /**\n   * @param  {string} localeKey\n   * @return {boolean} True if language is set.\n   * @memberof Localizer\n   */\n  setPrimaryLocale(localeKey) {\n    const key = this.getLocaleKey(localeKey);\n    if (key) {\n      this.primaryLanguage = key;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param  {string} localeKey\n   * @return {boolean} True if fallback is set.\n   * @memberof Localizer\n   */\n  setFallbackLocale(localeKey) {\n    const key = this.getLocaleKey(localeKey);\n    if (key) {\n      this.fallbackLanguage = key;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param  {string} localeKey\n   * @return {string}\n   * @memberof Localizer\n   */\n  getLocaleKey(localeKey) {\n    if (localeKey) {\n      let key = localeKey.toLowerCase();\n      if (this.locales[key]) {\n        return key;\n      }\n\n      if (key.indexOf('-') > 0) {\n        key = key.split('-')[0];\n        return this.getLocaleKey(key);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @private\n   * @return {void}\n   * @memberof Localizer\n   */\n  getBrowsersLocaleKey() {\n    const browserLanguages = this.getBrowserLanguages();\n    for (let i = 0, length = browserLanguages.length; i < length; i++) {\n      const key = this.getLocaleKey(browserLanguages[i]);\n      if (key) {\n        return key;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   *\n   * @return {string[]} An array of browser languages.\n   * @memberof Localizer\n   */\n  getBrowserLanguages() {\n    if (navigator.languages) {\n      return navigator.languages;\n    }\n\n    if (navigator.language) {\n      return [navigator.language || navigator.userLanguage];\n    }\n\n    return [];\n  }\n}\n","/**\n * Represents a single plugin for applications. Allows developers to inject code in the start up process of an\n * application providing new features to the application.\n * @class ApplicationPlugin\n */\nexport class ApplicationPlugin {\n  /**\n   * Creates a new Application plugin, with the provided priority.\n   * @param {Number} priority The priority of the plugin. A higher value for priority will cause the plugin to execute sooner.\n   */\n  constructor(priority = 0) {\n    this.priority = priority;\n  }\n\n  /**\n   * A setup method for the plugin. This method is ran synchronously in the constructor of the Application.\n   */\n  setup() {\n  }\n\n  /**\n   * A preload method for the plugin which allows for asynchronous setup tasks. Either takes a callback as first\n   * parameter, or should return a Promise indicating that loading is finished.\n   * @param {Function|undefined} callback A callback to call when finished (or no parameter at all).\n   * @return {Promise|undefined} If defined, treated as promise indicating when the plugin is finished loading.\n   */\n  preload() {\n    return Promise.resolve();\n  }\n}\n"],"names":["Debugger","level","initParams","toUpperCase","isValidLevelName","paramKey","minLevel","LEVEL","window","eventName","params","emitEnabled","dispatchEvent","Event","type","isEnabled","args","toLowerCase","meetsLevelRequirement","info","emit","debug","error","warn","log","isTrue","enabled","flag","ScaleManager","callback","undefined","width","height","Function","enable","onResize","this","bind","event","target","innerWidth","innerHeight","addEventListener","removeEventListener","SpeechSynth","voice","rate","pitch","volume","voiceOptions","voicesLoaded","queue","options","loadVoices","speechSynthesis","getVoices","setVoice","Array","isArray","length","speaking","pause","resume","cancel","message","speaker","SpeechSynthesisUtterance","assign","onend","_this","say","shift","speak","push","min","max","value","isNaN","index","rangeLimit","ColorFilter","element","document","getElementById","head","innerHTML","changeFilter","style","filter","Key","key","down","up","_state","actions","state","updateState","Controller","buttons","assignButtons","onKeyDown","onKeyUp","i","l","keys","action","e","onKey","BellhopEventDispatcher","_listeners","name","priority","_priority","parseInt","indexOf","sort","listenerSorter","a","b","splice","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","source","data","onConnectionReceived","trigger","postMessage","send","disconnect","HTMLIFrameElement","receive","runOnce","on","internalCallback","off","parent","contentWindow","Property","initialValue","_value","listeners","defineProperty","notifyChange","forEach","_this2","listener","StateManager","Error","Application","features","addField","Object","vo","music","sfxButton","sound","container","connect","property","containerEvent","match","exec","location","search","matchedToken","rawValue","decodeURIComponent","split","playOptions","JSON","parse","fetch","_plugins","plugin","setup","call","preloads","map","promisify","preload","all","catch","then","validateListeners","ready","Promise","resolve","reject","missingListeners","featureToStateMap","stateName","feature","_this3","hasListeners","join","uses","p1","p2","Caption","lines","endTime","reset","time","lineIndex","renderer","deltaTime","currentTime","lastTime","isFinished","lineEnd","line","startTime","lineBegin","TimedLine","content","setContent","text","replace","CaptionFactory","captions","caption","createCaption","captionData","createLine","lineData","start","end","CaptionPlayer","createCaptionMap","activeCaption","update","stop","IRender","DOMRenderer","templateVariables","HTMLElement","renderTarget","visibility","TemplateRenderer","template","_","HtmlRenderer","TextRenderer","innerText","sanitize","textContent","html","div","createElement","Localizer","config","locales","setPrimaryLocale","language","getBrowsersLocaleKey","default","setFallbackLocale","fallback","path","getLocaleKey","primaryLanguage","fallbackLanguage","primaryLocale","fallbackLocale","localeKey","browserLanguages","getBrowserLanguages","navigator","languages","userLanguage","ApplicationPlugin"],"mappings":"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"}