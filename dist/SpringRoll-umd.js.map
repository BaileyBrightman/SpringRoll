{"version":3,"file":"SpringRoll-umd.js","sources":["../src/debug/Debugger.js","../src/state/Property.js","../src/state/StateManager.js","../src/scale-manager/ScaleManager.js","../src/accessibility/SpeechSynth/SpeechSynth.js","../src/accessibility/ColorFilter/ColorFilter.js","../src/controller/Key.js","../src/controller/Controller.js","../node_modules/bellhop-iframe/dist/bellhop.js","../src/Application.js","../src/localization/captions/Caption.js","../src/localization/captions/TimedLine.js","../src/localization/captions/CaptionFactory.js","../src/localization/captions/CaptionPlayer.js","../src/localization/captions/renderers/IRenderer.js","../src/localization/captions/renderers/RendererDOM.js","../src/localization/captions/renderers/RendererTemplate.js","../src/localization/captions/renderers/RendererHTML.js","../src/localization/captions/renderers/RendererText.js","../src/localization/localizer/Localizer.js","../src/plugins/ApplicationPlugin.js"],"sourcesContent":["/**\n * @typedef {object} DebuggerParams\n * @property {boolean} emitEnabled\n * @property {boolean} enabled\n * @property {number} minLevel\n * @class Debugger\n * @param {Object} params - Options\n * @param {boolean} [params.emitEnabled=false] If this should emit events to the window.\n * @param {'GENERAL' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'} [params.minLevel='GENERAL'] The starting log level for the logger.\n */\nexport class Debugger {\n  /**\n   * Returns the params of the debugger.\n   * @returns {DebuggerParams}\n   * @readonly\n   * @static\n   * @memberof Debugger\n   */\n  static get params() {\n    Debugger.initParams();\n    return window[Debugger.paramKey];\n  }\n\n  /**\n   * Sets the logging level of the debugger.\n   * @param {string | number} level The name of the level.\n   * @return {void}\n   */\n  static minLevel(level) {\n    Debugger.initParams();\n    if ('number' === typeof level) {\n      window[Debugger.paramKey].minLevel = level;\n      return;\n    }\n\n    level = level.toUpperCase();\n    if (Debugger.isValidLevelName(level)) {\n      window[Debugger.paramKey].minLevel = Debugger.LEVEL[level];\n    } else {\n      window[Debugger.paramKey].minLevel = Debugger.LEVEL['GENERAL'];\n    }\n  }\n\n  /**\n   * Setup the params if not set already.\n   * @private\n   * @static\n   * @memberof Debugger\n   */\n  static initParams() {\n    if (!window[Debugger.paramKey]) {\n      window[Debugger.paramKey] = {\n        emitEnabled: false,\n        enabled: true,\n        minLevel: 1\n      };\n    }\n  }\n\n  /**\n   * If emitting is enabled for this instance, then it will dispatch an event on the window.\n   * @param {string} [eventName='Debugger'] Name of the event\n   */\n  static emit(eventName = 'Debugger') {\n    Debugger.initParams();\n    if (Debugger.params.emitEnabled) {\n      window.dispatchEvent(new Event(eventName));\n    }\n  }\n\n  /**\n   * Returns logging levels.\n   * @readonly\n   * @returns {object}\n   * @static\n   * @memberof Debugger\n   */\n  static get LEVEL() {\n    return {\n      GENERAL: 1,\n      DEBUG: 2,\n      INFO: 3,\n      WARN: 4,\n      ERROR: 5\n    };\n  }\n\n  /**\n   * Function to test if level meets requirements.\n   * @param {string} [level='GENERAL']\n   * @returns {boolean}\n   * @private\n   */\n  static meetsLevelRequirement(level = 'GENERAL') {\n    Debugger.initParams();\n    if (Debugger.isValidLevelName(level)) {\n      if (Debugger.LEVEL[level] >= Debugger.params.minLevel) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Console logs all supplied arguments if the log level is low enough for them to be logged.\n   * @param {'log' | 'general' | 'warn'| 'error' | 'debug' | 'info'} [type='log'] minimum level for this log to run at\n   * @param {*[]} args Arguments you wish to log.\n   */\n  static log(type = 'log', ...args) {\n    Debugger.initParams();\n    if (Debugger.isEnabled()) {\n      switch (type.toLowerCase()) {\n      case 'info':\n        if (Debugger.meetsLevelRequirement('INFO')) {\n          console.info(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'debug':\n        if (Debugger.meetsLevelRequirement('DEBUG')) {\n          console.debug(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'error':\n        if (Debugger.meetsLevelRequirement('ERROR')) {\n          console.error(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'warn':\n        if (Debugger.meetsLevelRequirement('WARN')) {\n          console.warn(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      case 'log':\n      case 'general':\n      default:\n        if (Debugger.meetsLevelRequirement('GENERAL')) {\n          console.log(...args);\n          Debugger.emit();\n          return true;\n        }\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Checks to see if the string argument is a valid level name.\n   * @param {string} level The level name.\n   * @return {boolean}\n   * @private\n   */\n  static isValidLevelName(level) {\n    Debugger.initParams();\n    if (\n      'GENERAL' == level ||\n      'DEBUG' == level ||\n      'INFO' == level ||\n      'WARN' == level ||\n      'ERROR' == level\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Will throw if statement is false.\n   * @static\n   * @param {boolean} isTrue The expression to evaluate.\n   */\n  static assert(isTrue) {\n    Debugger.initParams();\n    if (!isTrue) {\n      throw `Assert Error: ${isTrue}`;\n    }\n  }\n\n  /**\n   * Returns a boolean indicating if the debugger has been enabled or not.\n   * @static\n   * @returns {boolean}\n   */\n  static isEnabled() {\n    return window[Debugger.paramKey].enabled;\n  }\n\n  /**\n   * Disables or enables all debugger instances.\n   * @static\n   * @param {boolean} flag\n   * @returns {void}\n   */\n  static enable(flag) {\n    Debugger.initParams();\n    window[Debugger.paramKey].enabled = flag;\n  }\n\n  /**\n   * Returns the global params key.\n   * @readonly\n   * @static\n   * @memberof Debugger\n   */\n  static get paramKey() {\n    return '__spring_roll_debugger_params__';\n  }\n}\n","/**\n * A class for representing changeable/subscribable properties.\n * @class Property\n * @property {*} _value the value of the property\n * @property {[]} listeners all the objects listening to this property\n */\nexport class Property {\n  /**\n   * Creates a new property with an initial value.\n   * @param {*} initialValue The initial value of this property.\n   */\n  constructor(initialValue) {\n    this._value = initialValue;\n    this.listeners = [];\n  }\n\n  /**\n   * returns the current value of the property\n   * @readonly\n   * @returns {*}\n   * @memberof Property\n   */\n  get value() {\n    return this._value;\n  }\n  \n  /**\n   * Sets the value of the property and notifies all listeners of the change\n   * @param {*} value the new property value\n   * @memberof Property\n   */\n  set value(value) {\n    this._value = value;\n    this.notifyChange();\n  }\n\n  /**\n   * Notifies all subscribers to the property of a new value.\n   */\n  notifyChange() {\n    this.listeners.forEach(listener => {\n      listener(this._value);\n    });\n  }\n\n  /**\n   * Adds a subscriber to this property.\n   * @param {function} callback The callback to call whenever the property changes.\n   */\n  subscribe(callback) {\n    this.listeners.push(callback);\n  }\n\n  /**\n   * Unsubscribes a listener from this property.\n   * @param {function} callback The callback to unsubscribe.\n   */\n  unsubscribe(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  /**\n   * Whether or not this property has any subscribed listeners\n   * @return {Boolean} True if this property has at least one subscriber\n   */\n  get hasListeners() {\n    return this.listeners.length > 0;\n  }\n}\n","import { Property } from './Property.js';\n\n/**\n * A class for managing a group of subscribable properties together. Allows for the registration of new properties.\n * For example:\n * var manager = new StateManager();\n * manager.addField('paused', false);\n * manager.paused.subscribe(function(newValue) {\n *   console.log('New value is ', newValue);\n * })\n *\n * manager.paused = true;\n * @class StateManager\n */\nexport class StateManager {\n  /**\n   * Adds a new subscribable field field to the state manager. Throws an error if the field already exists.\n   * @param {String} name The name of the field.\n   * @param {*} initialValue The initial value of the property.\n   * @return Property The newly created property.\n   */\n  addField(name, initialValue) {\n    if ('undefined' !== typeof this[name]) {\n      throw new Error('\"' + name + '\" is already a registered property');\n    }\n\n    this[name] = new Property(initialValue);\n    return this[name];\n  }\n}\n","/**\n * Simplifies listening to resize events by passing the relevant data to a provided callback.\n * @class ScaleManager\n * @param {Function} [callback=undefined]\n * @property {Function} [callback=undefined]\n */\nexport class ScaleManager {\n  /**\n   *Creates an instance of ScaleManager.\n   */\n  constructor(callback) {\n    this.width = 1;\n    this.height = 1;\n    this.callback = callback;\n\n    if (callback instanceof Function) {\n      this.enable(callback);\n    }\n\n    this.onResize = this.onResize.bind(this);\n  }\n\n  /**\n   * onResize maps and passes the relevant data to the user provided callback function.\n   * @param {UIEvent} event\n   * @private\n   */\n  onResize(event) {\n    const width = event.target.innerWidth;\n    const height = event.target.innerHeight;\n\n    this.callback({\n      width,\n      height,\n      ratio: width / height\n    });\n\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Enables the scale manager listener. Will not be enabled if a callback is not supplied.\n   * @param {Function} callback The function to be called on resize events.\n   */\n  enable(callback) {\n    if (callback instanceof Function) {\n      this.callback = callback;\n      window.addEventListener('resize', this.onResize);\n    } else {\n      console.warn('Scale Manager was not passed a function');\n    }\n  }\n\n  /**\n   * Disables the scale manager.\n   */\n  disable() {\n    window.removeEventListener('resize', this.onResize);\n  }\n}\n","/**\n * SpeechSync makes it easy to convert text to speech.\n * @class SpeechSynth\n * @param {object} params\n * @param {number} [params.voice=0] Indicates what voice to use.\n * @param {number} [params.rate=1] The rate at which the text is said. Supports a range from 0.1 to 10.\n * @param {number} [params.pitch=0] Voice Pitch. Supports a pitch from 0 to 2.\n * @param {number} [params.volume=1] Volume. Supports 0 to 1.\n * @property {boolean} voicesLoaded voices are loaded async. This is will be set to true when they are loaded.\n */\nexport class SpeechSynth {\n  /**\n   * Creates an instance of SpeechSynth.\n   */\n  constructor({ voice = 0, rate = 1, pitch = 0, volume = 1 } = {}) {\n    this.voiceOptions = [];\n    this.voicesLoaded = false;\n    this.queue = [];\n\n    this.options = {\n      voice: {},\n      rate,\n      pitch,\n      volume\n    };\n\n    /**\n     * Called when voices are ready to be used.\n     * @private\n     */\n    const loadVoices = function() {\n      this.voiceOptions = window.speechSynthesis.getVoices();\n      this.voice = this.setVoice(voice);\n      this.voicesLoaded = true;\n    }.bind(this);\n\n    const voiceOptions = window.speechSynthesis.getVoices();\n    if (Array.isArray(voiceOptions) && 0 < voiceOptions.length) {\n      loadVoices();\n    } else {\n      window.speechSynthesis.addEventListener('voiceschanged', loadVoices, {\n        once: true\n      });\n    }\n  }\n\n  /**\n   * Pauses the announcer.\n   */\n  pause() {\n    this.speaking = false;\n    window.speechSynthesis.pause();\n  }\n\n  /**\n   * Resumes the announcer.\n   */\n  resume() {\n    this.speaking = true;\n    window.speechSynthesis.resume();\n  }\n\n  /**\n   * Pauses the announcer and clears the queue.\n   */\n  cancel() {\n    this.speaking = false;\n    this.pause();\n    this.queue.length = 0;\n    window.speechSynthesis.cancel();\n  }\n\n  /**\n   * Causes the announcer to say whatever message is passed to it.\n   * If the announcer is already saying something then it will be added to a queue.\n   * @param {string} message\n   */\n  say(message) {\n    if (this.speaking || !this.voicesLoaded) {\n      this.queue.push(message);\n      return;\n    }\n\n    const onEnd = () => {\n      this.speaking = false;\n\n      if (0 < this.queue.length) {\n        this.say(this.queue.shift());\n      }\n    };\n\n    this.speaking = true;\n\n    const speaker = new SpeechSynthesisUtterance(message);\n\n    Object.assign(speaker, this.options);\n\n    speaker.onend = onEnd;\n\n    window.speechSynthesis.speak(speaker);\n  }\n\n  /**\n   * Helper function to control the range of values.\n   * Will return the min value if not a number.\n   * @private\n   * @param {number} min\n   * @param {number} max\n   * @param {number} value\n   * @returns {number}\n   */\n  rangeLimit(min, max, value) {\n    if (isNaN(value)) {\n      console.warn(`'${value}' is not a valid number!`);\n      return min;\n    }\n\n    if (value >= max) {\n      return max;\n    }\n\n    if (min >= value) {\n      return min;\n    }\n\n    return value;\n  }\n\n  /**\n   * Sets the voice by array index.\n   * @param {number} index\n   */\n  setVoice(index) {\n    this.options.voice = this.voiceOptions[index];\n  }\n\n  /**\n   * Returns the voice object.\n   * @returns {object | null}\n   */\n  getVoice() {\n    return this.options.voice;\n  }\n\n  /**\n   * Rate at which text is spoken.\n   * @param {number} rate\n   */\n  set rate(rate) {\n    this.options.rate = this.rangeLimit(0.1, 10, rate);\n  }\n\n  /**\n   * Returns rate which text is spoken.\n   * @returns {number}\n   */\n  get rate() {\n    return this.options.rate;\n  }\n\n  /**\n   * Sets the pitch at which text is spoken.\n   * @param {number} pitch\n   */\n  set pitch(pitch) {\n    this.options.pitch = this.rangeLimit(0, 2, pitch);\n  }\n\n  /**\n   * Returns the pitch at which text is spoken.\n   * @returns {number}\n   */\n  get pitch() {\n    return this.options.pitch;\n  }\n\n  /**\n   * Sets the current volume of the announcer.\n   * @param {number} volume\n   */\n  set volume(volume) {\n    this.options.volume = this.rangeLimit(0, 1, volume);\n  }\n\n  /**\n   * Returns the current volume of the announcer.\n   * @returns {number}\n   */\n  get volume() {\n    return this.options.volume;\n  }\n}\n","/**\n * @typedef {'protanopia' | 'protanomaly'| 'deuteranopia' | 'deuteranomaly' | 'tritanopia' | 'tritanomaly' | 'achromatopsia'| 'achromatomaly' } filterType;\n */\n\n/**\n * The Color filter allows you to simulate colorblindness.\n * @export\n * @class ColorFilter\n */\nexport class ColorFilter {\n  /**\n   * Creates an instance of ColorFilter.\n   * @memberof ColorFilter\n   * @param {HTMLElement} element target html element to apply the filter too\n   * @param {filterType} type the\n   */\n  constructor(element = undefined, type = undefined) {\n    this.element = null;\n    if (null === document.getElementById('color__filter__svg')) {\n      const div = document.createElement('div');\n\n      div.style.width = '0';\n      div.style.height = '0';\n      div.style.position = 'absolute';\n      div.style.opacity = '0';\n\n\n      div.innerHTML += `<svg id=\"color__filter__svg\" style=\"width: 0; height: 0; position: absolute;\" xmlns=\"http://www.w3.org/2000/svg\"\n      version=\"1.1\">\n      <defs>\n        <filter id=\"color__filter__protanopia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.567, 0.433, 0,     0, 0\n                    0.558, 0.442, 0,     0, 0\n                    0,     0.242, 0.758, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__protanomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.817, 0.183, 0,     0, 0\n                    0.333, 0.667, 0,     0, 0\n                    0,     0.125, 0.875, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__deuteranopia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.625, 0.375, 0,   0, 0\n                    0.7,   0.3,   0,   0, 0\n                    0,     0.3,   0.7, 0, 0\n                    0,     0,     0,   1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__deuteranomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.8,   0.2,   0,     0, 0\n                    0.258, 0.742, 0,     0, 0\n                    0,     0.142, 0.858, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__tritanopia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.95, 0.05,  0,     0, 0\n                    0,    0.433, 0.567, 0, 0\n                    0,    0.475, 0.525, 0, 0\n                    0,    0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__tritanomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.967, 0.033, 0,     0, 0\n                    0,     0.733, 0.267, 0, 0\n                    0,     0.183, 0.817, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__achromatopsia\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.299, 0.587, 0.114, 0, 0\n                    0.299, 0.587, 0.114, 0, 0\n                    0.299, 0.587, 0.114, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n        <filter id=\"color__filter__achromatomaly\">\n          <feColorMatrix\n            in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.618, 0.320, 0.062, 0, 0\n                    0.163, 0.775, 0.062, 0, 0\n                    0.163, 0.320, 0.516, 0, 0\n                    0,     0,     0,     1, 0\"/>\n        </filter>\n      </defs>\n      </svg>\n      `;\n      document.body.appendChild(div);\n    }\n    if (element instanceof HTMLElement && 'string' === typeof type) {\n      this.applyFilter(element, type);\n    }\n  }\n\n  /**\n   * Applies the specified filter to the element.\n   * @param {HTMLElement} element\n   * @param {filterType} type\n   * @memberof ColorFilter\n   */\n  applyFilter(element, type) {\n    this.element = element;\n    this.changeFilter(type);\n  }\n\n  /**\n   * Changes the currently applied filter to the element if the color filter has it.\n   * @param {filterType} type\n   * @returns\n   * @memberof ColorFilter\n   */\n  changeFilter(type) {\n    if (null !== this.element) {\n      this.element.style.filter = `url(#color__filter__${type})`;\n    }\n  }\n\n  /**\n   * Removes the filter from the element.\n   * @memberof ColorFilter\n   */\n  removeFilter() {\n    this.element.style.filter = null;\n  }\n\n  /**\n   * Supported filter types.\n   * @readonly\n   * @memberof ColorFilter\n   * @returns { object } Returns an object { name, value } with the colorblindness type:\n   * (Protanopia, Protanomaly, Deuteranopia, Deuteranomaly, Tritanopia, Tritanomaly, Achromatopsia, Achromatomaly)\n   */\n  get types() {\n    return [\n      {\n        name: 'Protanopia',\n        value: 'protanopia'\n      },\n      {\n        name: 'Protanomaly',\n        value: 'protanomaly'\n      },\n      {\n        name: 'Deuteranopia',\n        value: 'deuteranopia'\n      },\n      {\n        name: 'Deuteranomaly',\n        value: 'deuteranomaly'\n      },\n      {\n        name: 'Tritanopia',\n        value: 'tritanopia'\n      },\n      {\n        name: 'Tritanomaly',\n        value: 'tritanomaly'\n      },\n      {\n        name: 'Achromatopsia',\n        value: 'achromatopsia'\n      },\n      {\n        name: 'Achromatomaly',\n        value: 'achromatomaly'\n      }\n    ];\n  }\n}\n","/**\n * Represents a single key on the keyboard and the functions related to it.\n * @class Key\n * @property {0 | 1 | 2} state The current state of the key. 0 = inactive, 1 = active, 2 = to be set to inactive.\n * @property {string} key The name of the key we are targeting.\n * @property {object} actions\n * @property {function} actions.down Function to be called while the key is held down.\n * @property {function} actions.up Function to be called when the key is lifted up.\n * @param {string} key What this object represents.\n * @param {Function} [down=() => {}] Function to be called while the key is held down.\n * @param {Function} [up=() => {}] Function to be called when the key is lifted up.\n */\nexport class Key {\n  /**\n   * Creates an instance of Key.\n   */\n  constructor(key, down, up) {\n    this.key = key;\n    this._state = 0;\n    this.actions = {\n      up,\n      down\n    };\n  }\n\n  /**\n   *\n   * Updates the internal state of the key. Accepts a range between 0-2. Will set key state to 0 if nothing is passed.\n   * @param {0 | 1 | 2} [state=0]\n   * @memberof Key\n   */\n  updateState(state = 0) {\n    if (state < 3 && state > -1) {\n      this._state = state;\n    }\n  }\n\n  /**\n   * Calls the relevant action for the current state of the key.\n   * @memberof Key\n   */\n  action() {\n    if (1 === this.state) {\n      this.actions.down();\n    } else if (2 === this.state) {\n      this.actions.up();\n      this.updateState(0);\n    }\n  }\n\n  /**\n   *\n   * Returns the current state of the key.\n   * @readonly\n   * @returns { number }\n   * @memberof Key\n   */\n  get state() {\n    return this._state;\n  }\n}\n","import { Key } from './Key';\n\n/**\n * @typedef {object} KeyTemplate\n * @property {Function} down\n * @property {Function} up\n * @property {string} key\n *\n * @typedef {0 | 1 | 2} KeyState\n */\n\n/**\n * Controller interface class to simplify working with key presses.\n * @export\n * @class Controller\n * @param {KeyTemplate[]} [buttons=[]] An object containing all keys you want to watch and their functions. e.g. {enter: () => {}}. See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for potential values.\n */\nexport class Controller {\n  /**\n   * Creates an instance of Controller.\n   * @memberof Controller\n   */\n  constructor(keys = []) {\n    this.assignButtons(keys);\n\n    window.addEventListener('keydown', this.onKeyDown.bind(this));\n    window.addEventListener('keyup', this.onKeyUp.bind(this));\n  }\n\n  /**\n   * Calls all functions for buttons that are currently set to enabled.\n   * @memberof Controller\n   */\n  update() {\n    for (let i = 0, l = this.keys.length; i < l; i++) {\n      this.buttons[this.keys[i]].action();\n    }\n  }\n\n  /**\n   * Called on keyup. Sets flag to 1 if key is being watched.\n   * @param {KeyboardEvent} e\n   * @memberof Controller\n   */\n  onKeyDown(e) {\n    this.onKey(e, 1);\n  }\n\n  /**\n   * Called on keyup. Sets flag to 2 if key is being watched.\n   * @param {KeyboardEvent} e\n   * @memberof Controller\n   */\n  onKeyUp(e) {\n    this.onKey(e, 2);\n  }\n\n  /**\n   * Sets an object of button functions to the controller to be called.\n   * @param {KeyTemplate[]} keys\n   * @memberof Controller\n   */\n  assignButtons(keys) {\n    this.buttons = {};\n    this.keys = [];\n    for (let i = 0, l = keys.length; i < l; i++) {\n      this.keys.push(keys[i].key);\n      this.buttons[keys[i].key] = new Key(\n        keys[i].key,\n        keys[i].down,\n        keys[i].up\n      );\n    }\n  }\n\n  /**\n   * Helper class to reduce code between event functions.\n   * @private\n   * @param {KeyboardEvent} event\n   * @param {KeyState} state\n   * @memberof Controller\n   */\n  onKey(event, state) {\n    const key = event.key.toLowerCase();\n    if (this.buttons[key]) {\n      this.buttons[key].updateState(state);\n    }\n  }\n}\n","/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nclass BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {Function} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} type The type of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(type, callback) {\n    if (this._listeners[type] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[type];\n      return;\n    }\n\n    const index = this._listeners[type].indexOf(callback);\n\n    -1 < index ? this._listeners[type].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {Object | String} event The event to send\n   */\n  trigger(event) {\n    if (typeof event == 'string') {\n      event = {\n        type: event\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nclass Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {Boolean} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {DOMElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      // Ignore all other message if we don't have a context\n      if (\n        this.connected &&\n        'object' === typeof message.data &&\n        message.data.type\n      ) {\n        this.trigger(message.data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0, length = this._sendLater.length; i < length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive.bind(this));\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(message, this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object} data The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n\nexport { BellhopEventDispatcher, Bellhop };\n//# sourceMappingURL=bellhop.js.map\n","import { Bellhop } from 'bellhop-iframe';\nimport { Debugger } from './debug/Debugger.js';\nimport { StateManager } from './state/StateManager.js';\n\nconst ready = 'ready';\nconst pause = 'pause';\nconst captionsMuted = 'captionsMuted';\nconst playOptions = 'playOptions';\nconst soundVolume = 'soundVolume';\nconst musicVolume = 'musicVolume';\nconst voVolume = 'voVolume';\nconst sfxVolume = 'sfxVolume';\n\n/**\n * Main entry point for a game. Provides a single focal point for plugins and functionality to attach.\n * @class Application\n */\nexport class Application {\n  /**\n   * Creates a new application, setting up plugins along the way.\n   * @param {Object} features A configuration object denoting which features are enabled for this application\n   * @param {Boolean} features.captions A boolean value denoting that this game supports captions\n   * @param {Boolean} features.sound A boolean value denoting that this game has some audio in it\n   * @param {Boolean} features.vo A boolean denoting that this game has mutable voice-over audio in it\n   * @param {Boolean} features.music A boolean denoting that this game has mutable music in it\n   * @param {Boolean} features.sfx A boolean denoting that this game has mutable sound effects in it\n   */\n  constructor(features) {\n    /**\n     * @member {StateManager} The state manager for this application instance. Maintains subscribable properties for\n     *                        whether or not audio is muted, captions are displayed, or the game is paused.\n     */\n    this.state = new StateManager();\n    this.state.addField(ready, false);\n    this.state.addField(pause, false);\n    this.state.addField(captionsMuted, true);\n    this.state.addField(playOptions, {});\n\n    this.state.addField(soundVolume, 1);\n    this.state.addField(musicVolume, 1);\n    this.state.addField(voVolume, 1);\n    this.state.addField(sfxVolume, 1);\n\n    this.features = Object.assign(\n      {\n        captions: false,\n        sound: false,\n        vo: false,\n        music: false,\n        sfx: false\n      },\n      features || {}\n    );\n\n    // always enable sound if one of the sound channels is enabled\n    if (this.features.vo || this.features.music || this.features.sfx) {\n      this.features.sound = true;\n    }\n\n    // create the connection to the container (if possible), and report features and SpringRoll 1 compat data\n    this.container = new Bellhop();\n    this.container.connect();\n    this.container.send('features', this.features);\n    this.container.send('keepFocus', false);\n\n    // listen for events from the container and keep the local value in sync\n    [\n      soundVolume,    \n      musicVolume,\n      voVolume,\n      sfxVolume,\n      captionsMuted,\n      pause\n    ].forEach(eventName => {\n      const property = this.state[eventName];\n      this.container.on(\n        eventName,\n        containerEvent => (property.value = containerEvent.data)\n      );\n    });\n\n    // listen for legacy mute events from the container and map them to volume properties\n    [\n      { mute: 'soundMuted', volume: soundVolume },\n      { mute: 'musicMuted', volume: musicVolume },\n      { mute: 'voMuted', volume: voVolume },\n      { mute: 'sfxMuted', volume: sfxVolume }\n    ].forEach(pair => {\n      const property = this.state[pair.volume];\n      this.container.on(pair.mute, containerEvent => {\n        const previousValue = property._previousValue || 1;\n        property._previousValue = property.value;\n        property.value = containerEvent.data ? 0 : previousValue;\n      });\n    });\n\n    // maintain focus sync between the container and application\n    window.addEventListener('focus', () => this.container.send('focus', true));\n    window.addEventListener('blur', () => this.container.send('focus', false));\n\n    // attempt to fetch play options from the query string (passed by the Container)\n    const match = /playOptions=[^&$]*/.exec(window.location.search);\n    if (match !== null) {\n      const matchedToken = match[0];\n      const rawValue = decodeURIComponent(matchedToken.split('=')[1]);\n\n      try {\n        this.playOptions = JSON.parse(rawValue);\n      } catch (e) {\n        Debugger.log(\n          'warn',\n          'Failed to parse playOptions from query string:' + e.message\n        );\n      }\n    }\n\n    // Also attempt to fetch over the iframe barrier for old container support\n    this.container.fetch('playOptions', e => (this.playOptions.value = e.data));\n\n    // check for any invalid plugins\n    const errorMessages = Application.validatePlugins();\n    if (errorMessages.length > 0) {\n      const message = errorMessages.join('. ') + '.';\n      throw new Error(message);\n    }\n\n    Application.sortPlugins();\n\n    Application._plugins.forEach(plugin => plugin.setup(this));\n\n    // loop over each plugin and chain their asynchronous preload calls in order. This enforces load order for\n    // asynchronous tasks too, given that we just sorted them\n    let preloader = Promise.resolve();\n    for (const plugin of Application._plugins) {\n      preloader = preloader.then(() => plugin.preload(this));\n    }\n\n    preloader\n      .catch(e => {\n        Debugger.log('warn', e);\n      })\n      .then(() => {\n        this.validateListeners();\n      })\n      .catch(e => {\n        Debugger.log('warn', e);\n      })\n      .then(() => {\n        this.container.send('loaded');\n        this.state.ready.value = true;\n      });\n  }\n\n  /**\n   * Validates that appropriate listeners are added for the features that were enabled in the constructor\n   * @throws Error\n   */\n  validateListeners() {\n    const missingListeners = [];\n\n    const featureToStateMap = {\n      captions: captionsMuted,\n      sound: soundVolume,\n      music: musicVolume,\n      vo: voVolume,\n      sfx: sfxVolume\n    };\n\n    Object.keys(featureToStateMap).forEach(feature => {\n      const stateName = featureToStateMap[feature];\n\n      if (this.features[feature] && !this.state[stateName].hasListeners) {\n        missingListeners.push(stateName);\n      }\n    });\n\n    if (!this.state.pause.hasListeners) {\n      missingListeners.push('pause');\n    }\n\n    if (missingListeners.length) {\n      throw new Error(\n        'Application state is missing required listeners: ' +\n          missingListeners.join(', ') +\n          '.'\n      );\n    }\n  }\n\n  /**\n   * Validates every plugin to make sure it has it's required dependencies\n   *\n   * @return Array<string>\n   */\n  static validatePlugins() {\n    const errors = [];\n\n    const registeredPluginNames = Application._plugins.map(plugin => plugin.name);\n\n    Application._plugins\n      .forEach(plugin => {\n        const name = plugin.name;\n\n        // for this plugins, find all required plugins that are missing from the full plugin list\n        const missingRequired = plugin.required\n          .filter(name => registeredPluginNames.indexOf(name) < 0)\n          .map(name => `\"${name}\"`); // format them too\n\n        if (missingRequired.length === 0) {\n          return;\n        }\n\n        // if there were required plugins not in Application._plugins, add this to the error list for later\n        const errorMessage = `Application plugin \"${name}\" missing required plugins ${ missingRequired.join(', ') }`;\n        errors.push(errorMessage);\n      });\n\n    return errors;\n  }\n\n  /**\n   * Helper method for sorting plugins in place. Looks at dependency order and performs a topological sort to enforce\n   * proper load error\n   */\n  static sortPlugins() {\n    if (Application._plugins.length === 0) {\n      return; // nothing to do\n    }\n\n    const pluginNames = Application._plugins.map(plugin => plugin.name);\n    const pluginLookup = {};\n    Application._plugins.forEach(plugin => {\n      // for any optional plugins that are missing remove them from the list and warn along the way\n      const optionalAvailablePlugins = plugin.optional.filter(name => {\n        if (pluginNames.indexOf(name) === -1) {\n          Debugger.log('warn', plugin.name + ' missing optional plugin ' + name);\n          return false;\n        }\n\n        return true;\n      });\n\n      pluginLookup[plugin.name] = {\n        plugin: plugin,\n        name: plugin.name,\n        dependencies: [].concat(plugin.required).concat(optionalAvailablePlugins)\n      };\n    });\n\n    const visited = [];\n    const toVisit = new Set();\n\n    // first, add items that do not have any dependencies\n    Object.keys(pluginLookup)\n      .map(key => pluginLookup[key])\n      .filter(lookup => lookup.dependencies.length === 0)\n      .forEach(lookup => toVisit.add(lookup.name));\n\n    // if there are no items to visit, throw an error\n    if (toVisit.size === 0) {\n      throw new Error('Every registered plugin has a dependency!');\n    }\n\n    while (toVisit.size > 0) {\n      // pick an item and remove it from the list\n      const item = toVisit.values().next().value;\n      toVisit.delete(item);\n\n      // add it to the visited list\n      visited.push(item);\n\n      // for every plugin\n      Object.keys(pluginLookup).forEach(pluginName => {\n        const index = pluginLookup[pluginName].dependencies.indexOf(item);\n\n        // remove it as a dependency\n        if (index > -1) {\n          pluginLookup[pluginName].dependencies.splice(index, 1);\n        }\n\n        // if there are no more dependencies left, we can visit this item now\n        if (pluginLookup[pluginName].dependencies.length === 0 && visited.indexOf(pluginName) === -1) {\n          toVisit.add(pluginName);\n        }\n      });\n    }\n\n    // if there are any dependencies left, that means that there's a cycle\n    const uncaughtKeys = Object.keys(pluginLookup)\n      .filter(pluginName => pluginLookup[pluginName].dependencies.length > 0);\n\n    if (uncaughtKeys.length > 0) {\n      throw new Error('Dependency graph has a cycle');\n    }\n\n    // now, rebuild the array\n    Application._plugins = [];\n    visited.forEach(name => {\n      Application._plugins.push(pluginLookup[name].plugin);\n    });\n  }\n}\n\n/**\n * The list of plugins that are currently registered to run on Applications.\n * @static\n */\nApplication._plugins = [];\n\n/**\n * @typedef {typeof import('./plugins/ApplicationPlugin.js').ApplicationPlugin} ApplicationPlugin\n */\n\n/**\n * Registers a plugin to be used by applications, sorting it by priority order.\n * @param {ApplicationPlugin} plugin The plugin to register.\n */\nApplication.uses = function(plugin) {\n  Application._plugins.push(plugin);\n};\n","/**\n * @typedef {import('./TimedLine.js').TimedLine} TimedLine\n * @typedef {import('./renderers/IRenderer.js').IRender} IRender\n */\n/**\n * @export\n * @class Caption\n * @property {TimedLine[]} lines\n * @property {number} time\n * @property {number} lineIndex\n * @property {IRender} renderer\n */\nexport class Caption {\n  /**\n   * Creates an instance of Caption.\n   * @param {TimedLine[]} lines - Array of lines to be used for caption.\n   * @memberof Caption\n   */\n  constructor(lines) {\n    this.lines = lines;\n\n    // Sort by end time, this ensures proper execution order of lines.\n    this.lines.sort(function(a, b) {\n      if (a.endTime < b.endTime) {\n        return -1;\n      }\n\n      if (a.endTime > b.endTime) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    this.reset();\n  }\n\n  /**\n   * Resets time, lineIndex and content fields.\n   * @private\n   * @memberof Caption\n   */\n  reset() {\n    this.time = 0;\n    this.lineIndex = 0;\n    this.renderer = null;\n  }\n\n  /**\n   * Updates content based on time passed.\n   * This ~should~ be called every frame that the caption is active.\n   *\n   * @param {Number} deltaTime - Time in seconds since last frame.\n   * @memberof Caption\n   */\n  update(deltaTime) {\n    const time = this.time + deltaTime * 1000;\n    if (time === this.time) {\n      return;\n    }\n\n    this.updateState(time, this.time);\n    this.time = time;\n  }\n\n  /**\n   * Handles calling callbacks and updating caption's current state.\n   * @param  {Number} currentTime\n   * @param  {Number} lastTime\n   * @memberof Caption\n   */\n  updateState(currentTime, lastTime) {\n    if (this.isFinished()) {\n      return;\n    }\n    if (currentTime > this.lines[this.lineIndex].endTime) {\n      this.renderer.lineEnd();\n    }\n\n    while (currentTime > this.lines[this.lineIndex].endTime) {\n      if (this.lineIndex++ ,this.isFinished()) {\n        return;\n      }\n    }\n\n    const line = this.lines[this.lineIndex];\n    if (currentTime >= line.startTime && lastTime < line.startTime) {\n      this.renderer.lineBegin(line);\n      return;\n    }\n  }\n\n  /**\n   * Checks if caption has completed.\n   * @returns {Boolean}\n   * @memberof Caption\n   */\n  isFinished() {\n    return this.lineIndex >= this.lines.length;\n  }\n\n  /**\n   * Sets time and line index of caption.\n   *\n   * @param {Number} [time=0] - Time in milliseconds.\n   * @memberof Caption\n   */\n  start(time = 0, renderer = { lineBegin: () => {}, lineEnd: () => {} }) {\n    this.reset();\n    this.renderer = renderer;\n    this.updateTimeIndex(time);\n    this.updateState(this.time, this.lines[this.lineIndex].startTime - 1);\n  }\n\n  /**\n   * Updates the current time and index of the caption instance\n   * @param {Number} [time=0]\n   * @memberof Caption\n   */\n  updateTimeIndex(time = 0) {\n    this.time = time;\n    if (this.isFinished()) {\n      return;\n    }\n    for (let i = this.lines.length - 1; i > -1; i--) {\n      if (this.lines[i].startTime <= time) {\n        this.lineIndex = i;\n        break;\n      }\n    }\n  }\n}\n","/**\n * @export\n * @property {number} startTime\n * @property {number} endTime\n * @property {string} content\n * @class TimedLine\n */\nexport class TimedLine {\n  /**\n   * Creates an instance of TimedLine.\n   * @param {Number} startTime - Start time in milliseconds relative to caption.\n   * @param {Number} endTime - End time in milliseconds relative to caption.\n   * @param {string} content - HMTL formatted string content to show during time-span.\n   * @memberof TimedLine\n   */\n  constructor(startTime, endTime, content) {\n    this.startTime = startTime || 0;\n    this.endTime = endTime || 0;\n    this.content = '';\n    this.setContent(content);\n  }\n\n  /**\n   * Sets line's content. Removes HTML formatting for text.\n   * @param  {any} content\n   * @return {void}@memberof TimedLine\n   */\n  setContent(content) {\n    this.content = content;\n  }\n}\n","import { Debugger } from './../../debug/Debugger';\nimport { Caption } from './Caption';\nimport { TimedLine } from './TimedLine';\n\n/**\n * Collection of functions for creating Captions\n *\n * @export\n * @class CaptionFactory\n */\nexport class CaptionFactory {\n  /**\n   * Creates a new Object<String, Caption>.\n   *\n   * @static\n   * @param {JSON} data\n   * @returns {Object}\n   * @memberof CaptionFactory\n   */\n  static createCaptionMap(data) {\n    const captions = {};\n    for (const key in data) {\n      const caption = this.createCaption(data[key]);\n      if (!caption) {\n        Debugger.log(\n          'error',\n          '[CaptionFactory.createCaptionMap] failed to create caption:',\n          key\n        );\n      } else {\n        captions[key] = caption;\n      }\n    }\n    return captions;\n  }\n\n  /**\n   * Creates a new Caption from JSON data.\n   *\n   * @static\n   * @param {*} captionData\n   * @returns {Caption} new Caption\n   * @memberof CaptionFactory\n   */\n  static createCaption(captionData) {\n    const lines = [];\n    for (let i = 0, length = captionData.length; i < length; i++) {\n      const line = this.createLine(captionData[i]);\n      if (line) {\n        lines.push(line);\n      }\n    }\n\n    if (lines.length <= 0) {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createCaption] captions should not have 0 lines.'\n      );\n      return;\n    }\n\n    return new Caption(lines);\n  }\n\n  /**\n   * Creates a new TimedLine from JSON data.\n   *\n   * @static\n   * @param {*} lineData\n   * @returns {TimedLine} new TimedLine;\n   * @memberof CaptionFactory\n   */\n  static createLine(lineData) {\n    if (typeof lineData.start !== 'number') {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createLine] lineData.start must be defined as a number'\n      );\n      return;\n    }\n\n    if (typeof lineData.end !== 'number') {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createLine] lineData.end must be defined as a number'\n      );\n      return;\n    }\n\n    if (typeof lineData.content !== 'string') {\n      Debugger.log(\n        'error',\n        '[CaptionFactory.createLine] lineData.content must be defined as a string'\n      );\n      return;\n    }\n\n    if (lineData.content === '') {\n      Debugger.log(\n        'warn',\n        '[CaptionFactory.createLine] lineData.content should not be empty',\n        'Its recommended to add time to the start of the next line to add delays.'\n      );\n      return;\n    }\n\n    return new TimedLine(lineData.start, lineData.end, lineData.content);\n  }\n}\n","import { Debugger } from '../../debug/Debugger';\nimport { CaptionFactory } from './CaptionFactory';\n\n/**\n * @typedef {import('./renderers/IRenderer.js').IRender} IRender\n */\n\n/**\n *  CaptionPlayer is used to start, stop and update captions.\n *  It applies the content of an active caption to a given CaptionRenderer.\n *\n * @export\n * @class CaptionPlayer\n/*\n *\n * @export\n * @class CaptionPlayer\n */\nexport class CaptionPlayer {\n  /**\n   * Creates an instance of CaptionPlayer.\n   * @param {*} captions - Captions map.\n   * @param {IRender} renderer CaptionRenderer that content is applied to.\n   * @memberof CaptionPlayer\n   */\n  constructor(captions, renderer) {\n    this.captions = CaptionFactory.createCaptionMap(captions);\n\n    this.renderer = renderer;\n\n    this.activeCaption = null;\n  }\n\n  /**\n   * Updates any currently playing caption.\n   * This ~should~ be called every frame.\n   *\n   * @param {Number} deltaTime Time passed in seconds since last update call.\n   * @memberof CaptionPlayer\n   */\n  update(deltaTime) {\n    if (this.activeCaption) {\n      this.activeCaption.update(deltaTime);\n      if (this.activeCaption.isFinished()) {\n        this.stop();\n      }\n    }\n  }\n\n  /**\n   * Starts playing a caption.\n   *\n   * @param {String} name Name of caption.\n   * @param {number} [time=0] Atart time in milliseconds.\n   * @param {object} [args = {}] Arguments that will get passed to the renderer\n   * @memberof CaptionPlayer\n   */\n  start(name, time = 0, args = {}) {\n    this.stop();\n    this.activeCaption = this.captions[name];\n    if (this.activeCaption) {\n      this.renderer.start(args);\n      this.activeCaption.start(time, this.renderer);\n      return;\n    }\n\n    Debugger.log('warn', `[CaptionPlayer.Start()] caption ${name} not found`);\n  }\n\n  /**\n   * Stops any caption currently playing.\n   * @memberof CaptionPlayer\n   */\n  stop() {\n    if (this.activeCaption) {\n      if (this.renderer.stop) {\n        this.renderer.stop();\n      }\n    }\n    this.activeCaption = null;\n  }\n}\n","/**\n * Render interface to help enforce minimum requirements for caption renderers\n * @interface\n * @class IRender\n * @property {function} start called when the Caption Player starts playing captions\n * @property {function} stop called when the Caption Player stops playing captions\n * @property {function} lineBegin called when rendering a new line of text\n * @property {function} lineEnd called when finished rendering a new of text\n */\nexport class IRender {\n  /**\n   *Creates an instance of Renderer.\n   * @memberof Renderer\n   */\n  constructor() {\n    if (\n      'function' !== typeof this.start ||\n      'function' !== typeof this.stop ||\n      'function' !== typeof this.lineBegin ||\n      'function' !== typeof this.lineEnd\n    ) {\n      console.error(\n        'Springroll Caption Renderer not implemented corrected. Please ensure you have a \"start\", \"end\", \"lineBegin\", and \"lineEnd\" function in your class.'\n      );\n    }\n  }\n}\n","import { IRender } from './IRenderer';\n/**\n *\n * DOMRender is a incomplete renderer that is intended to supply just the basic start and stop functions\n * @export\n * @class DOMRenderer\n * @param {HTMLElement} element\n * @param {Object} templateVariables\n */\nexport class DOMRenderer extends IRender {\n  /**\n   *Creates an instance of DOMRenderer.\n   * @memberof DOMRenderer\n   */\n  constructor(element, templateVariables = {}) {\n    super();\n\n    if (!(element instanceof HTMLElement)) {\n      console.error('Invalid html element provided to renderer');\n    }\n\n    this.renderTarget = element;\n    this.templateVariables = templateVariables;\n  }\n  /**\n   * Makes target element visible and ready to present captions\n   * @param {object} [templateVariables = {}] Variables that can used during caption play time\n   * @memberof DOMRenderer\n   */\n  start(templateVariables = {}) {\n    this.renderTarget.style.visibility = 'visible';\n    this.templateVariables = templateVariables;\n  }\n\n  /**\n   *\n   * H\n   * @memberof DOMRenderer\n   */\n  stop() {\n    this.renderTarget.style.visibility = 'hidden';\n    this.templateVariables = {};\n  }\n}\n","/**\n * TemplateRenderer accepts a string template e.g.`The ball is {{color}}` and a args object e.g. `{color: 'red'}`\n * and swaps out the placeholder inside the double brackets with the matching key inside the args object\n * @export\n * @param {string} template String template that will be rendered with the supplied arguments\n * @param {Object} args //An Object contain data to be inserted into the template This will match based on key values\n * @returns {string}\n */\nexport function TemplateRenderer(template, args) {\n  return template.replace(\n    /{{([a-zA-Z][A-Za-z0-9]*)}}/g,\n    (_, key) => args[key] || _\n  );\n}\n","import { DOMRenderer } from './RendererDOM';\nimport { TemplateRenderer } from './RendererTemplate';\n/**\n *\n * HTML Renderer is intended for rendering raw html in the use case of wanting to display styled captions\n * @export\n * @class HtmlRenderer\n * @implements {RendererInterface}\n */\nexport class HtmlRenderer extends DOMRenderer {\n  /**\n   *\n   * Called by Caption Player when a new line needs to be displayed\n   * @memberof HtmlRenderer\n   */\n  lineBegin(line) {\n    this.renderTarget.innerHTML = TemplateRenderer(\n      line.content,\n      this.templateVariables\n    );\n  }\n\n  /**\n   *\n   * Called by Caption Player when a line is complete\n   * @memberof HtmlRenderer\n   */\n  lineEnd() {\n    this.renderTarget.innerHTML = '';\n  }\n}\n","import { TemplateRenderer } from './RendererTemplate';\nimport { DOMRenderer } from './RendererDOM';\n/**\n *\n * TextRenderer is intended for just rendering test. It will attempt to sanitize any strings passed to it by removing html syntax\n * @export\n * @class TextRenderer\n * @implements {RendererInterface}\n */\nexport class TextRenderer extends DOMRenderer {\n  /**\n   *\n   * Called by Caption Player when a new line needs to be displayed\n   * @memberof TextRenderer\n   */\n  lineBegin(line) {\n    this.renderTarget.innerText = this.sanitize(\n      TemplateRenderer(line.content, this.templateVariables)\n    );\n  }\n\n  /**\n   *\n   * Called by Caption Player when a line is complete\n   * @memberof TextRenderer\n   */\n  lineEnd() {\n    this.renderTarget.textContent = '';\n  }\n\n  /**\n   *\n   * Will attempt to remove all html from a string before it's renderer to the page\n   * @param {*} html\n   * @memberof TextRenderer\n   */\n  sanitize(html) {\n    const div = document.createElement('div');\n    div.innerHTML = html;\n    return div.textContent || div.innerText || '';\n  }\n}\n","/**\n * @typedef {{path: string}} Locale\n * @typedef {{default: string, locales: { name: Locale }}} Localizer.Config\n * @typedef {{language: string, fallback: string}} Localizer.Options\n */\n\n/**\n * @export\n * @class Localizer\n */\nexport class Localizer {\n  /**\n   * Creates an instance of Localizer.\n   * @param {Localizer.Config} config\n   * @param {Localizer.Options} [options={}]\n   * @memberof Localizer\n   */\n  constructor(config, options = {}) {\n    this.locales = config.locales;\n\n    this.setPrimaryLocale(\n      options.language || this.getBrowsersLocaleKey() || config.default\n    );\n    this.setFallbackLocale(options.fallback || config.default);\n  }\n\n  /**\n   *\n   * @param  {string} path\n   * @param  {any} [options={}]\n   * @return {{path: string, language: string}}\n   * @memberof Localizer\n   */\n  resolve(path, options = {}) {\n    const language = options.language\n      ? this.getLocaleKey(options.language)\n      : this.primaryLanguage;\n    const fallback =\n      this.getLocaleKey(options.fallback) || this.fallbackLanguage;\n\n    const primaryLocale = this.locales[language];\n    const fallbackLocale = this.locales[fallback];\n\n    if (primaryLocale) {\n      return { path: primaryLocale.path + path, language: language };\n    }\n\n    if (fallbackLocale) {\n      return { path: fallbackLocale.path + path, language: fallback };\n    }\n  }\n\n  /**\n   * @param  {string} localeKey\n   * @return {boolean} True if language is set.\n   * @memberof Localizer\n   */\n  setPrimaryLocale(localeKey) {\n    const key = this.getLocaleKey(localeKey);\n    if (key) {\n      this.primaryLanguage = key;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param  {string} localeKey\n   * @return {boolean} True if fallback is set.\n   * @memberof Localizer\n   */\n  setFallbackLocale(localeKey) {\n    const key = this.getLocaleKey(localeKey);\n    if (key) {\n      this.fallbackLanguage = key;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param  {string} localeKey\n   * @return {string}\n   * @memberof Localizer\n   */\n  getLocaleKey(localeKey) {\n    if (localeKey) {\n      let key = localeKey.toLowerCase();\n      if (this.locales[key]) {\n        return key;\n      }\n\n      if (key.indexOf('-') > 0) {\n        key = key.split('-')[0];\n        return this.getLocaleKey(key);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @private\n   * @return {void | string}\n   * @memberof Localizer\n   */\n  getBrowsersLocaleKey() {\n    const browserLanguages = this.getBrowserLanguages();\n    for (let i = 0, length = browserLanguages.length; i < length; i++) {\n      const key = this.getLocaleKey(browserLanguages[i]);\n      if (key) {\n        return key;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   *\n   * @return {ReadonlyArray[*] | []} An array of browser languages.\n   * @memberof Localizer\n   */\n  getBrowserLanguages() {\n    if (navigator.languages) {\n      return navigator.languages;\n    }\n\n    if (navigator.language) {\n      return [navigator.language || navigator.userLanguage];\n    }\n\n    return [];\n  }\n}\n","/**\n * Represents a single plugin for applications. Allows developers to inject code in the start up process of an\n * application providing new features to the application.\n * @class ApplicationPlugin\n */\nexport class ApplicationPlugin {\n  /**\n   * Creates a new Application plugin with a given name and other required plugins\n   * @param {Object} options The configuration options to the plugin\n   * @param {String} options.name The name of the plugin. Used by other plugins to specify a dependency on the plugin\n   * @param {Array<String>} options.required The list of required plugins (by name) that this plugin depends on\n   * @param {Array<String>} options.optional The list of optional plugins (by name) that this plugin depends on\n   */\n  constructor(options = {}) {\n    if (options.name === undefined) {\n      throw new Error('Application plugin not provided a name field');\n    }\n\n    this.name = options.name;\n    this.required = options.required || [];\n    this.optional = options.optional || [];\n  }\n\n  /**\n   * A setup method for the plugin. This method is ran synchronously in the constructor of the Application.\n   */\n  setup() {}\n\n  /**\n   * A preload method for the plugin which allows for asynchronous setup tasks. Either takes a callback as first\n   * parameter, or should return a Promise indicating that loading is finished.\n   * @return {Promise} A promise indicating when the plugin is finished loading.\n   */\n  preload() {\n    return Promise.resolve();\n  }\n}\n"],"names":["Debugger","level","initParams","toUpperCase","isValidLevelName","paramKey","minLevel","LEVEL","window","eventName","params","emitEnabled","dispatchEvent","Event","type","isEnabled","args","toLowerCase","meetsLevelRequirement","info","emit","debug","error","warn","log","isTrue","enabled","flag","Property","initialValue","_value","listeners","forEach","_this","callback","push","this","filter","listener","set","value","notifyChange","length","StateManager","name","Error","ScaleManager","width","height","Function","enable","onResize","bind","event","target","innerWidth","innerHeight","addEventListener","removeEventListener","SpeechSynth","voice","rate","pitch","volume","voiceOptions","voicesLoaded","queue","options","loadVoices","speechSynthesis","getVoices","setVoice","Array","isArray","speaking","pause","resume","cancel","message","speaker","SpeechSynthesisUtterance","assign","onend","say","shift","speak","min","max","isNaN","index","rangeLimit","get","ColorFilter","element","undefined","document","getElementById","div","createElement","style","position","opacity","innerHTML","body","appendChild","HTMLElement","applyFilter","changeFilter","Key","key","down","up","_state","actions","state","updateState","Controller","keys","assignButtons","onKeyDown","onKeyUp","i","l","buttons","action","e","onKey","BellhopEventDispatcher","_listeners","priority","_priority","parseInt","indexOf","sort","listenerSorter","a","b","splice","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","source","data","onConnectionReceived","trigger","postMessage","send","disconnect","HTMLIFrameElement","receive","runOnce","on","internalCallback","off","parent","contentWindow","ready","captionsMuted","playOptions","soundVolume","musicVolume","voVolume","sfxVolume","Application","features","addField","Object","vo","music","sfx","sound","container","connect","property","containerEvent","mute","pair","previousValue","_previousValue","match","exec","location","search","matchedToken","rawValue","decodeURIComponent","split","JSON","parse","fetch","errorMessages","validatePlugins","join","sortPlugins","_plugins","plugin","setup","preloader","Promise","resolve","then","preload","catch","validateListeners","missingListeners","featureToStateMap","stateName","feature","_this2","hasListeners","errors","registeredPluginNames","map","missingRequired","required","errorMessage","pluginNames","pluginLookup","optionalAvailablePlugins","optional","concat","visited","toVisit","Set","lookup","dependencies","add","size","item","values","next","delete","pluginName","uses","Caption","lines","endTime","reset","time","lineIndex","renderer","deltaTime","currentTime","lastTime","isFinished","lineEnd","line","startTime","lineBegin","updateTimeIndex","TimedLine","content","setContent","CaptionFactory","captions","caption","createCaption","captionData","createLine","lineData","start","end","CaptionPlayer","createCaptionMap","activeCaption","update","stop","IRender","DOMRenderer","templateVariables","renderTarget","visibility","TemplateRenderer","template","replace","_","HtmlRenderer","TextRenderer","innerText","sanitize","textContent","html","Localizer","config","locales","setPrimaryLocale","language","getBrowsersLocaleKey","default","setFallbackLocale","fallback","path","getLocaleKey","primaryLanguage","fallbackLanguage","primaryLocale","fallbackLocale","localeKey","browserLanguages","getBrowserLanguages","navigator","languages","userLanguage","ApplicationPlugin"],"mappings":"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"}