<!DOCTYPE html>
<html lang='en'>

<head>
  <title>SpringRoll v0.2.0 API Documentation : src/media/Sound.js</title>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
  <link rel='shortcut icon' type='image/png' href='../assets/images/favicon.ico?v=0.2.0'>
  <link href='//fonts.googleapis.com/css?family=Titillium+Web:300,200,600' rel='stylesheet' type='text/css'>
  <link rel='stylesheet' type='text/css' href='../assets/css/libraries.css?v=0.2.0'>
  <link rel='stylesheet' type='text/css' href='../assets/css/main.css?v=0.2.0'>
</head>

<body>
  <header>
    <div class='container'>
      <div class='version pull-right'>
        <em>API Documentation for: 0.2.0</em>
      </div>
      <div class='logo'>

        <h1><a href='https://github.com/SpringRoll/SpringRoll'><img src='../assets/images/logo.png?v=0.2.0' title='SpringRoll'><span class='project-name'>SpringRoll</span></a></h1> 
      </div>
<div class='scope-toggles pull-right'>
  <input class='scope-toggle' id='toggle-inherited' type='checkbox' data-toggle='toggle' data-on='Inherited' data-off='Inherited' data-size='mini'>
  <input class='scope-toggle' id='toggle-protected' type='checkbox' data-toggle='toggle' data-on='Protected' data-off='Protected' data-size='mini'>
  <input class='scope-toggle' id='toggle-private' type='checkbox' data-toggle='toggle' data-on='Private' data-off='Private' data-size='mini'>
  <input class='scope-toggle' id='toggle-deprecated' type='checkbox' data-toggle='toggle' data-on='Deprecated' data-off='Deprecated' data-size='mini'>
</div>    </div>
  </header>
  <div class='container'>
    <div class='row'>
      <nav id='sidebar' class='col-sm-4 col-md-3'>
<h2>APIs</h2>
<div class='input-group'>
  <div class='input-group-addon'>
    <span class='glyphicon glyphicon-search'></span>
  </div>
  <input type='search' class='form-control' id='api-filter' placeholder='Type to filter APIs'>
</div>
<nav class='navbar navbar-default'>
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="btn-group" role="group" aria-label="...">
    <button type="button" class="sidebar-toggle collapsed btn btn-default" id='toggle-classes' data-target='#classes-collapse'>
      Classes
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
    <button type="button" class="sidebar-toggle collapsed btn btn-default"id='toggle-modules'  data-target='#modules-collapse'>
      Modules
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='classes-collapse'>
    <ul class='nav navbar-nav'>
        <li class=''>
          <a href='../classes/createjs.Container.html'>createjs.Container</a>
        </li>
        <li class=''>
          <a href='../classes/createjs.MovieClip.html'>createjs.MovieClip</a>
        </li>
        <li class=''>
          <a href='../classes/createjs.Point.html'>createjs.Point</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.AbstractDisplay.html'>springroll.AbstractDisplay</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.AbstractHint.html'>springroll.AbstractHint</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.AnimatorHint.html'>springroll.AnimatorHint</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Application.html'>springroll.Application</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.ApplicationOptions.html'>springroll.ApplicationOptions</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.BaseState.html'>springroll.BaseState</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.CacheManager.html'>springroll.CacheManager</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Captions.html'>springroll.Captions</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.CombinedCallback.html'>springroll.CombinedCallback</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Debug.html'>springroll.Debug</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.DebugOptions.html'>springroll.DebugOptions</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.DelayedCall.html'>springroll.DelayedCall</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.Animator.html'>springroll.easeljs.Animator</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.AnimatorTimeline.html'>springroll.easeljs.AnimatorTimeline</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.AssetManager.html'>springroll.easeljs.AssetManager</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.BasePanel.html'>springroll.easeljs.BasePanel</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.BaseState.html'>springroll.easeljs.BaseState</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.BitmapMovieClip.html'>springroll.easeljs.BitmapMovieClip</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.BitmapUtils.html'>springroll.easeljs.BitmapUtils</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.Button.html'>springroll.easeljs.Button</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.Cutscene.html'>springroll.easeljs.Cutscene</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.DisplayAdapter.html'>springroll.easeljs.DisplayAdapter</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.DragManager.html'>springroll.easeljs.DragManager</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.DwellTimer.html'>springroll.easeljs.DwellTimer</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.EaselJSDisplay.html'>springroll.easeljs.EaselJSDisplay</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.ReversePlayback.html'>springroll.easeljs.ReversePlayback</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.SoundButton.html'>springroll.easeljs.SoundButton</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.Texture.html'>springroll.easeljs.Texture</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.TextureAtlas.html'>springroll.easeljs.TextureAtlas</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.easeljs.TrackingGame.html'>springroll.easeljs.TrackingGame</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Enum.html'>springroll.Enum</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.EnumValue.html'>springroll.EnumValue</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.EventCatalog.html'>springroll.EventCatalog</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.EventDispatcher.html'>springroll.EventDispatcher</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.EventError.html'>springroll.EventError</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.EventSignature.html'>springroll.EventSignature</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.EventUtils.html'>springroll.EventUtils</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Features.html'>springroll.Features</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.FunctionHint.html'>springroll.FunctionHint</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.FunctionTask.html'>springroll.FunctionTask</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Game.html'>springroll.Game</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.GameContainer.html'>springroll.GameContainer</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.GroupHint.html'>springroll.GroupHint</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.HintPlayer.html'>springroll.HintPlayer</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Language.html'>springroll.Language</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.ListTask.html'>springroll.ListTask</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Loader.html'>springroll.Loader</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.LoaderQueueItem.html'>springroll.LoaderQueueItem</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.LoaderResult.html'>springroll.LoaderResult</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.LoadTask.html'>springroll.LoadTask</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.native.Circle.html'>springroll.native.Circle</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.native.DisplayAdapter.html'>springroll.native.DisplayAdapter</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.native.Ellipse.html'>springroll.native.Ellipse</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.native.NativeDisplay.html'>springroll.native.NativeDisplay</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.native.Point.html'>springroll.native.Point</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.native.Polygon.html'>springroll.native.Polygon</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.native.Rectangle.html'>springroll.native.Rectangle</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.PageVisibility.html'>springroll.PageVisibility</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.Animator.html'>springroll.pixi.Animator</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.AnimatorTimeline.html'>springroll.pixi.AnimatorTimeline</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.AssetManager.html'>springroll.pixi.AssetManager</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.Button.html'>springroll.pixi.Button</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.DisplayAdapter.html'>springroll.pixi.DisplayAdapter</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.DragManager.html'>springroll.pixi.DragManager</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.ParallelSpineData.html'>springroll.pixi.ParallelSpineData</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.pixi.PixiDisplay.html'>springroll.pixi.PixiDisplay</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.PixiTask.html'>springroll.PixiTask</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Positioner.html'>springroll.Positioner</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.ProgressTracker.html'>springroll.ProgressTracker</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.ProgressTrackerError.html'>springroll.ProgressTrackerError</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.PropertyDispatcher.html'>springroll.PropertyDispatcher</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.SavedData.html'>springroll.SavedData</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Sound.html'>springroll.Sound</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.SoundContext.html'>springroll.SoundContext</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.SoundInstance.html'>springroll.SoundInstance</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.SoundListTask.html'>springroll.SoundListTask</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.StateEvent.html'>springroll.StateEvent</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.StateManager.html'>springroll.StateManager</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.StringFilters.html'>springroll.StringFilters</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.Task.html'>springroll.Task</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.TaskEvent.html'>springroll.TaskEvent</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.TaskManager.html'>springroll.TaskManager</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.TimeUtils.html'>springroll.TimeUtils</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.TrackingGame.html'>springroll.TrackingGame</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.TrackingGameMedia.html'>springroll.TrackingGameMedia</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.UIElement.html'>springroll.UIElement</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.UIElementSettings.html'>springroll.UIElementSettings</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.UIScaler.html'>springroll.UIScaler</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.ValidationError.html'>springroll.ValidationError</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.VOHint.html'>springroll.VOHint</a>
        </li>
        <li class=''>
          <a href='../classes/springroll.VOPlayer.html'>springroll.VOPlayer</a>
        </li>
        <li class=''>
          <a href='../classes/window.Array.html'>window.Array</a>
        </li>
        <li class=''>
          <a href='../classes/window.extend.html'>window.extend</a>
        </li>
        <li class=''>
          <a href='../classes/window.include.html'>window.include</a>
        </li>
        <li class=''>
          <a href='../classes/window.Math.html'>window.Math</a>
        </li>
        <li class=''>
          <a href='../classes/window.namespace.html'>window.namespace</a>
        </li>
        <li class=''>
          <a href='../classes/window.Object.html'>window.Object</a>
        </li>
        <li class=''>
          <a href='../classes/window.String.html'>window.String</a>
        </li>
    </ul>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='modules-collapse'>
    <ul class='nav navbar-nav'>
        <li class=''>
          <a href='../modules/Captions.html'>Captions</a>
        </li>
        <li class=''>
          <a href='../modules/Container.html'>Container</a>
        </li>
        <li class=''>
          <a href='../modules/Core.html'>Core</a>
        </li>
        <li class=''>
          <a href='../modules/Debug.html'>Debug</a>
        </li>
        <li class=''>
          <a href='../modules/EaselJS Animation.html'>EaselJS Animation</a>
        </li>
        <li class=''>
          <a href='../modules/EaselJS Cutscene.html'>EaselJS Cutscene</a>
        </li>
        <li class=''>
          <a href='../modules/EaselJS Display.html'>EaselJS Display</a>
        </li>
        <li class=''>
          <a href='../modules/EaselJS Interface.html'>EaselJS Interface</a>
        </li>
        <li class=''>
          <a href='../modules/EaselJS Tracking Game.html'>EaselJS Tracking Game</a>
        </li>
        <li class=''>
          <a href='../modules/EaselJS Utilities.html'>EaselJS Utilities</a>
        </li>
        <li class=''>
          <a href='../modules/Game.html'>Game</a>
        </li>
        <li class=''>
          <a href='../modules/Hinting.html'>Hinting</a>
        </li>
        <li class=''>
          <a href='../modules/Interface.html'>Interface</a>
        </li>
        <li class=''>
          <a href='../modules/Native Display.html'>Native Display</a>
        </li>
        <li class=''>
          <a href='../modules/PIXI Animation.html'>PIXI Animation</a>
        </li>
        <li class=''>
          <a href='../modules/PIXI Display.html'>PIXI Display</a>
        </li>
        <li class=''>
          <a href='../modules/PIXI Interface.html'>PIXI Interface</a>
        </li>
        <li class=''>
          <a href='../modules/Progress Tracker.html'>Progress Tracker</a>
        </li>
        <li class=''>
          <a href='../modules/Sound.html'>Sound</a>
        </li>
        <li class=''>
          <a href='../modules/Tasks.html'>Tasks</a>
        </li>
        <li class=''>
          <a href='../modules/Tracking Game.html'>Tracking Game</a>
        </li>
        <li class=''>
          <a href='../modules/Translate.html'>Translate</a>
        </li>
    </ul>
  </div>
  <!-- /.container-fluid -->
</nav>      </nav>
      <div class='col-sm-8 col-md-9'>
        <div id='docs-main' class='apidocs'>
<script>
  var name = {
  	{
  		name
  	}
  }
</script>
<h1 class="file-heading">File:Sound.js</h1>

<div class="file">
  <pre class="code prettyprint linenums">/**
 * @module Sound
 * @namespace springroll
 * @requires Core
 */
(function()
{
	var Application = include(&#x27;springroll.Application&#x27;),
		Debug,
		Loader,
		LoadTask,
		TaskManager,
		SoundContext,
		SoundInstance,
		SoundListTask,
		WebAudioPlugin = include(&#x27;createjs.WebAudioPlugin&#x27;),
		FlashAudioPlugin = include(&#x27;createjs.FlashAudioPlugin&#x27;, false),
		SoundJS = include(&#x27;createjs.Sound&#x27;),
		Enum = include(&#x27;springroll.Enum&#x27;);

	/**
	*  Acts as a wrapper for SoundJS as well as adding lots of other functionality
	*  for managing sounds.
	*
	*  @class Sound
	*/
	var Sound = function()
	{
		// Import classes
		if (!Loader)
		{
			Debug = include(&#x27;springroll.Debug&#x27;, false);
			Loader = include(&#x27;springroll.Loader&#x27;);
			LoadTask = include(&#x27;springroll.LoadTask&#x27;, false);
			TaskManager = include(&#x27;springroll.TaskManager&#x27;, false);
			SoundContext = include(&#x27;springroll.SoundContext&#x27;);
			SoundInstance = include(&#x27;springroll.SoundInstance&#x27;);
			SoundListTask = include(&#x27;springroll.SoundListTask&#x27;, false);
		}

		/**
		*  Dictionary of sound objects, containing configuration info and playback objects.
		*  @property {Object} _sounds
		*  @private
		*/
		this._sounds = {};

		/**
		*  Array of SoundInstance objects that are being faded in or out.
		*  @property {Array} _fades
		*  @private
		*/
		this._fades = [];

		/**
		*  Array of SoundInstance objects waiting to be used.
		*  @property {Array} _pool
		*  @private
		*/
		this._pool = [];

		/**
		*  The extension of the supported sound type that will be used.
		*  @property {string} supportedSound
		*  @public
		*/
		this.supportedSound = null;

		/**
		*  Dictionary of SoundContexts.
		*  @property {Object} _contexts
		*  @private
		*/
		this._contexts = {};

		// Bindings
		this._update = this._update.bind(this);
		this._markLoaded = this._markLoaded.bind(this);
		this._playAfterLoad = this._playAfterLoad.bind(this);

		/**
		*  If sound is enabled. This will only be false if Sound was unable to initialize
		*  a SoundJS plugin.
		*  @property {Boolean} soundEnabled
		*  @readOnly
		*/
		this.soundEnabled = true;
	};

	var p = Sound.prototype = {};

	var _instance = null;
	
	//sound states
	var LoadStates = new Enum(&quot;unloaded&quot;, &quot;loading&quot;, &quot;loaded&quot;);

	/**
	*  Initializes the Sound singleton. If using createjs.FlashAudioPlugin, you will be responsible for
	*  setting createjs.FlashAudioPlugin.BASE_PATH.
	*  @method init
	*  @static
	*  @param {Object|Function} options Either the options object or the ready function
	*  @param {Array} [options.plugins=createjs.WebAudioPlugin,createjs.FlashAudioPlugin] The SoundJS
	*                                         plugins to pass to createjs.Sound.registerPlugins().
	*  @param {Array} [options.types=[&#x27;ogg&#x27;,&#x27;mp3&#x27;]] The order in which file types are preferred,
	*                                               where &quot;ogg&quot; becomes a &quot;.ogg&quot; extension on all
	*                                               sound file urls.
	*  @param {String} [options.swfPath=&#x27;assets/swfs/&#x27;] The required path to the
	*                                                   createjs.FlashAudioPlugin SWF
	*  @param {Function} [options.ready] A function to call when initialization is complete.
	*  @return {Sound} The new instance of the sound object
	*/
	Sound.init = function(options, readyCallback)
	{
		var appOptions = Application.instance.options;
		// First argument is function
		if (typeof options == &#x27;function&#x27;)
		{
			options = { ready: options };
		}

		var _defaultOptions = {
			plugins : appOptions.forceFlashAudio ?
						[FlashAudioPlugin] : [WebAudioPlugin, FlashAudioPlugin],
			types: [&#x27;ogg&#x27;, &#x27;mp3&#x27;],
			swfPath: &#x27;assets/swfs/&#x27;,
			ready: null
		};

		options = options || {};

		//set up default options
		for (var key in _defaultOptions)
		{
			if (!options.hasOwnProperty(key))
				options[key] = _defaultOptions[key];
		}

		// Check if the ready callback is the second argument
		// this is deprecated
		options.ready = options.ready || readyCallback;

		if (!options.ready)
		{
			throw &quot;springroll.Sound.init requires a ready callback&quot;;
		}

		if (FlashAudioPlugin)
		{
			// Apply the base path if available
			var basePath = appOptions.basePath;
			FlashAudioPlugin.swfPath = (basePath || &quot;&quot;) + options.swfPath;
		}

		SoundJS.registerPlugins(options.plugins);

		//If on iOS, then we need to add a touch listener to unmute sounds.
		//playback pretty much has to be createjs.WebAudioPlugin for iOS
		if (createjs.BrowserDetect.isIOS &amp;&amp;
			SoundJS.activePlugin instanceof WebAudioPlugin)
		{
			document.addEventListener(&quot;touchstart&quot;, _playEmpty);
		}

		// New sound object
		_instance = new Sound();

		//make sure the capabilities are ready (looking at you, Cordova plugin)
		if (SoundJS.getCapabilities())
		{
			_instance._initComplete(options.types, options.ready);
		}
		else if (SoundJS.activePlugin)
		{
			if (DEBUG &amp;&amp; Debug)
			{
				Debug.log(&quot;SoundJS Plugin &quot; + SoundJS.activePlugin + &quot; was not ready, waiting until it is&quot;);
			}
			//if the sound plugin is not ready, then just wait until it is
			var waitFunction;
			waitFunction = function()
			{
				if (SoundJS.getCapabilities())
				{
					Application.instance.off(&quot;update&quot;, waitFunction);
					_instance._initComplete(options.types, options.ready);
				}
			};

			Application.instance.on(&quot;update&quot;, waitFunction);
		}
		else
		{
			if (DEBUG &amp;&amp; Debug) Debug.error(&quot;Unable to initialize SoundJS with a plugin!&quot;);
			this.soundEnabled = false;
			if (options.ready)
				options.ready();
		}
		return _instance;
	};

	/**
	*  Statisfies the iOS event needed to initialize the audio
	*  @private
	*  @method _playEmpty
	*/
	function _playEmpty()
	{
		document.removeEventListener(&quot;touchstart&quot;, _playEmpty);
		WebAudioPlugin.playEmptySound();
	}

	/**
	*  When the initialization as completed
	*  @method
	*  @private
	*  @param {Array} filetypeOrder The list of files types
	*  @param {Function} callback The callback function
	*/
	p._initComplete = function(filetypeOrder, callback)
	{
		if (FlashAudioPlugin &amp;&amp; SoundJS.activePlugin instanceof FlashAudioPlugin)
		{
			_instance.supportedSound = &quot;.mp3&quot;;
		}
		else
		{
			var type;
			for (var i = 0, len = filetypeOrder.length; i &lt; len; ++i)
			{
				type = filetypeOrder[i];
				if (SoundJS.getCapability(type))
				{
					_instance.supportedSound = &quot;.&quot; + type;
					break;
				}
			}
		}

		this.pauseAll = this.pauseAll.bind(this);
		this.unpauseAll = this.unpauseAll.bind(this);
		this.destroy = this.destroy.bind(this);

		// Add listeners to pause and resume the sounds
		Application.instance.on({
			paused : this.pauseAll,
			resumed : this.unpauseAll,
			destroy : this.destroy
		});

		if (callback)
		{
			callback();
		}
	};

	/**
	*  The singleton instance of Sound.
	*  @property {Sound} instance
	*  @public
	*  @static
	*/
	Object.defineProperty(Sound, &quot;instance&quot;,
	{
		get: function() { return _instance; }
	});

	/**
	*  Loads a config object. This should not be called until after Sound.init() is complete.
	*  @method loadConfig
	*  @public
	*  @param {Object} config The config to load.
	*  @param {String} [config.context] The optional sound context to load sounds into unless
	*                                   otherwise specified by the individual sound. Sounds do not
	*                                   require a context.
	*  @param {String} [config.path=&quot;&quot;] The path to prepend to all sound source urls in this config.
	*  @param {Array} config.soundManifest The list of sounds, either as String ids or Objects with
	*                                      settings.
	*  @param {Object|String} config.soundManifest.listItem Not actually a property called listItem,
	*                                                       but an entry in the array. If this is a
	*                                                       string, then it is the same as
	*                                                       {&#x27;id&#x27;:&#x27;&lt;yourString&gt;&#x27;}.
	*  @param {String} config.soundManifest.listItem.id The id to reference the sound by.
	*  @param {String} [config.soundManifest.listItem.src] The src path to the file, without an
	*                                                      extension. If omitted, defaults to id.
	*  @param {Number} [config.soundManifest.listItem.volume=1] The default volume for the sound,
	*                                                           from 0 to 1.
	*  @param {Boolean} [config.soundManifest.listItem.loop=false] If the sound should loop by
	*                                                              default whenever the loop
	*                                                              parameter in play() is not
	*                                                              specified.
	*  @param {String} [config.soundManifest.listItem.context] A context name to override
	*                                                          config.context with.
	*  @param {Boolean} [config.soundManifest.listItem.preload] If the sound should be preloaded
	*                                                           immediately.
	*  @return {Sound} The sound object for chaining
	*/
	p.loadConfig = function(config)
	{
		if (!config)
		{
			if (DEBUG &amp;&amp; Debug) Debug.warn(&quot;Warning - springroll.Sound was told to load a null config&quot;);
			return;
		}
		var list = config.soundManifest;
		var path = config.path || &quot;&quot;;
		var defaultContext = config.context;

		var s;
		var temp = {};
		for (var i = 0, len = list.length; i &lt; len; ++i)
		{
			s = list[i];
			if (typeof s == &quot;string&quot;) {
				s = {id: s};
			}
			temp = this._sounds[s.id] = {
				id: s.id,
				src: path + (s.src ? s.src : s.id) + this.supportedSound,
				volume: s.volume ? s.volume : 1,
				loop: !!s.loop,
				loadState: LoadStates.unloaded,
				playing: [],
				waitingToPlay: [],
				context: s.context || defaultContext,
				playAfterLoad: false,
				preloadCallback: null,
				data:s,//save data for potential use by SoundJS plugins
				duration:0
			};
			if (temp.context)
			{
				if (!this._contexts[temp.context])
					this._contexts[temp.context] = new SoundContext(temp.context);
				this._contexts[temp.context].sounds.push(temp);
			}
			//preload the sound for immediate-ish use
			if(s.preload === true)
			{
				this.preloadSound(temp.id);
			}
		}
		//return the Sound instance for chaining
		return this;
	};

	/**
	*	If a sound exists in the list of recognized sounds.
	*	@method exists
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {Boolean} true if the sound exists, false otherwise.
	*/
	p.exists = function(alias)
	{
		return !!this._sounds[alias];
	};

	/**
	*	If a sound is unloaded.
	*	@method isUnloaded
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {Boolean} true if the sound is unloaded, false if it is loaded, loading or does not exist.
	*/
	p.isUnloaded = function(alias)
	{
		return this._sounds[alias] ? this._sounds[alias].loadState == LoadStates.unloaded : false;
	};

	/**
	*	If a sound is loaded.
	*	@method isLoaded
	*	@public
	*	@param {String} alias The alias of the sound to look for.
	*	@return {Boolean} true if the sound is loaded, false if it is not loaded or does not exist.
	*/
	p.isLoaded = function(alias)
	{
		return this._sounds[alias] ? this._sounds[alias].loadState == LoadStates.loaded : false;
	};

	/**
	*  If a sound is in the process of being loaded
	*  @method isLoading
	*  @public
	*  @param {String} alias The alias of the sound to look for.
	*  @return {Boolean} A value of true if the sound is currently loading, false if it is loaded,
	*                    unloaded, or does not exist.
	*/
	p.isLoading = function(alias)
	{
		return this._sounds[alias] ? this._sounds[alias].loadState == LoadStates.loading : false;
	};

	/**
	*  If a sound is playing.
	*  @method isPlaying
	*  @public
	*  @param {String} alias The alias of the sound to look for.
	*  @return {Boolean} A value of true if the sound is currently playing or loading with an intent
	*                    to play, false if it is not playing or does not exist.
	*/
	p.isPlaying = function(alias)
	{
		var sound = this._sounds[alias];
		return sound ? sound.playing.length + sound.waitingToPlay.length &gt; 0 : false;
	};
	
	/**
	*  Gets the duration of a sound in milliseconds, if it has been loaded.
	*  @method getDuration
	*  @public
	*  @param {String} alias The alias of the sound to look for.
	*  @return {int|null} The duration of the sound in milliseconds. If the sound has not been
	*                     loaded, 0 is returned. If no sound exists by that alias, null is returned.
	*/
	p.getDuration = function(alias)
	{
		var sound = this._sounds[alias];
		
		if(!sound) return null;
		
		if(!sound.duration)//sound hasn&#x27;t been loaded yet
		{
			if(sound.loadState == LoadStates.loaded)
			{
				//play the sound once to get the duration of it
				var channel = SoundJS.play(alias, null, null, null, null, /*volume*/0);
				sound.duration = channel.getDuration();
				//stop the sound
				channel.stop();
			}
		}
		
		return sound.duration;
	};

	/**
	*  Fades a sound from 0 to a specified volume.
	*  @method fadeIn
	*  @public
	*  @param {String|SoundInstance} aliasOrInst The alias of the sound to fade the last played
	*                                            instance of, or an instance returned from play().
	*  @param {Number} [duration=500] The duration in milliseconds to fade for. The default is
	*                                 500ms.
	*  @param {Number} [targetVol] The volume to fade to. The default is the sound&#x27;s default volume.
	*  @param {Number} [startVol=0] The volume to start from. The default is 0.
	*/
	p.fadeIn = function(aliasOrInst, duration, targetVol, startVol)
	{
		var sound, inst;
		if (typeof(aliasOrInst) == &quot;string&quot;)
		{
			sound = this._sounds[aliasOrInst];
			if (!sound) return;
			if (sound.playing.length)
				inst = sound.playing[sound.playing.length - 1];//fade the last played instance
		}
		else
		{
			inst = aliasOrInst;
			sound = this._sounds[inst.alias];
		}
		if (!inst || !inst._channel) return;
		inst._fTime = 0;
		inst._fDur = duration &gt; 0 ? duration : 500;
		var v = startVol &gt; 0 ? startVol : 0;
		inst._channel.setVolume(v);
		inst.curVol = inst._fStart = v;
		inst._fEnd = targetVol || sound.volume;
		if (this._fades.indexOf(inst) == -1)
		{
			this._fades.push(inst);
			if (this._fades.length == 1)
			{
				Application.instance.on(&quot;update&quot;, this._update);
			}
		}
	};

	/**
	*  Fades a sound from the current volume to a specified volume. A sound that ends at 0 volume
	*  is stopped after the fade.
	*  @method fadeOut
	*  @public
	*  @param {String|SoundInstance} aliasOrInst The alias of the sound to fade the last played
	*                                            instance of, or an instance returned from play().
	*  @param {Number} [duration=500] The duration in milliseconds to fade for. The default is
	*                                 500ms.
	*  @param {Number} [targetVol=0] The volume to fade to. The default is 0.
	*  @param {Number} [startVol] The volume to fade from. The default is the current volume.
	*/
	p.fadeOut = function(aliasOrInst, duration, targetVol, startVol)
	{
		var sound, inst;
		if (typeof(aliasOrInst) == &quot;string&quot;)
		{
			sound = this._sounds[aliasOrInst];
			if (!sound) return;
			if (sound.playing.length)
				inst = sound.playing[sound.playing.length - 1];//fade the last played instance
		}
		else
		{
			inst = aliasOrInst;
			//sound = this._sounds[inst.alias];
		}
		if (!inst || !inst._channel) return;
		inst._fTime = 0;
		inst._fDur = duration &gt; 0 ? duration : 500;
		if (startVol &gt; 0)
		{
			inst._channel.setVolume(startVol);
			inst._fStart = startVol;
		}
		else
			inst._fStart = inst._channel.getVolume();
		inst.curVol = inst._fStart;
		inst._fEnd = targetVol || 0;
		if (this._fades.indexOf(inst) == -1)
		{
			this._fades.push(inst);
			if (this._fades.length == 1)
			{
				Application.instance.on(&quot;update&quot;, this._update);
			}
		}
	};

	/**
	*	The update call, used for fading sounds. This is bound to the instance of Sound
	*	@method _update
	*	@private
	*	@param {int} elapsed The time elapsed since the previous frame, in milliseconds.
	*/
	p._update = function(elapsed)
	{
		var fades = this._fades;
		var trim = 0;

		var inst, time, sound,swapIndex, lerp, vol;
		for (var i = fades.length - 1; i &gt;= 0; --i)
		{
			inst = fades[i];
			if (inst.paused) continue;
			time = inst._fTime += elapsed;
			if (time &gt;= inst._fDur)
			{
				if (inst._fEnd === 0)
				{
					sound = this._sounds[inst.alias];
					sound.playing = sound.playing.splice(sound.playing.indexOf(inst), 1);
					this._stopInst(inst);
				}
				else
				{
					inst.curVol = inst._fEnd;
					inst.updateVolume();
				}
				++trim;
				swapIndex = fades.length - trim;
				if (i != swapIndex)//don&#x27;t bother swapping if it is already last
				{
					fades[i] = fades[swapIndex];
				}
			}
			else
			{
				lerp = time / inst._fDur;
				if (inst._fEnd &gt; inst._fStart)
					vol = inst._fStart + (inst._fEnd - inst._fStart) * lerp;
				else
					vol = inst._fEnd + (inst._fStart - inst._fEnd) * lerp;
				inst.curVol = vol;
				inst.updateVolume();
			}
		}
		fades.length = fades.length - trim;
		if (fades.length === 0)
		{
			Application.instance.off(&quot;update&quot;, this._update);
		}
	};

	/**
	*  Plays a sound.
	*  @method play
	*  @public
	*  @param {String} alias The alias of the sound to play.
	*  @param {Object|function} [options] The object of optional parameters or complete callback
	*                                     function.
	*  @param {Function} [options.complete] An optional function to call when the sound is finished.
	*  @param {Function} [options.start] An optional function to call when the sound starts
	*                                    playback. If the sound is loaded, this is called
	*                                    immediately, if not, it calls when the sound is finished
	*                                    loading.
	*  @param {Boolean} [options.interrupt=false] If the sound should interrupt previous sounds
	*                                             (SoundJS parameter). Default is false.
	*  @param {Number} [options.delay=0] The delay to play the sound at in milliseconds (SoundJS
	*                                    parameter). Default is 0.
	*  @param {Number} [options.offset=0] The offset into the sound to play in milliseconds
	*                                     (SoundJS parameter). Default is 0.
	*  @param {int} [options.loop=0] How many times the sound should loop. Use -1 (or true) for
	*                                infinite loops (SoundJS parameter). Default is no looping.
	*  @param {Number} [options.volume] The volume to play the sound at (0 to 1). Omit to use the
	*                                   default for the sound.
	*  @param {Number} [options.pan=0] The panning to start the sound at (-1 to 1). Default is
	*                                  centered (0).
	*  @return {SoundInstance} An internal SoundInstance object that can be used for fading in/out
	*                             as well as pausing and getting the sound&#x27;s current position.
	*/
	p.play = function (alias, options, startCallback, interrupt, delay, offset, loop, volume, pan)
	{
		if (!this.soundEnabled) return;

		var completeCallback;
		if (options &amp;&amp; typeof options == &quot;function&quot;)
		{
			completeCallback = options;
			options = null;
		}
		completeCallback = (options ? options.complete : completeCallback) || null;
		startCallback = (options ? options.start : startCallback) || null;
		interrupt = !!(options ? options.interrupt : interrupt);
		delay = (options ? options.delay : delay) || 0;
		offset = (options ? options.offset : offset) || 0;
		loop = (options ? options.loop : loop);
		volume = (options ? options.volume : volume);
		pan = (options ? options.pan : pan) || 0;

		//Replace with correct infinite looping.
		if (loop === true)
			loop = -1;

		var sound = this._sounds[alias];
		if (!sound)
		{
			if (DEBUG &amp;&amp; Debug) Debug.error(&quot;springroll.Sound: alias &#x27;&quot; + alias + &quot;&#x27; not found!&quot;);

			if (completeCallback)
				completeCallback();
			return;
		}
		//check for sound loop settings
		if (sound.loop &amp;&amp; loop === undefined || loop === null)
			loop = -1;
		//check for sound volume settings
		volume = (typeof(volume) == &quot;number&quot;) ? volume : sound.volume;
		//take action based on the sound state
		var loadState = sound.loadState;
		var inst, arr;
		if (loadState == LoadStates.loaded)
		{
			var channel = SoundJS.play(alias, interrupt, delay, offset, loop, volume, pan);
			//have Sound manage the playback of the sound

			if (!channel || channel.playState == SoundJS.PLAY_FAILED)
			{
				if (completeCallback)
					completeCallback();
				return null;
			}
			else
			{
				inst = this._getSoundInst(channel, sound.id);
				if (channel.handleExtraData)
					channel.handleExtraData(sound.data);
				inst.curVol = volume;
				sound.playing.push(inst);
				inst._endCallback = completeCallback;
				inst.updateVolume();
				inst.length = channel.getDuration();
				if(!sound.duration)
					sound.duration = inst.length;
				inst._channel.addEventListener(&quot;complete&quot;, inst._endFunc);
				if (startCallback)
					setTimeout(startCallback, 0);
				return inst;
			}
		}
		else if (loadState == LoadStates.unloaded)
		{
			sound.loadState = LoadStates.loading;
			sound.playAfterLoad = true;
			inst = this._getSoundInst(null, sound.id);
			inst.curVol = volume;
			sound.waitingToPlay.push(inst);
			inst._endCallback = completeCallback;
			inst._startFunc = startCallback;
			if (inst._startParams)
			{
				arr = inst._startParams;
				arr[0] = interrupt;
				arr[1] = delay;
				arr[2] = offset;
				arr[3] = loop;
				arr[4] = pan;
			}
			else
				inst._startParams = [interrupt, delay, offset, loop, pan];
			Loader.instance.load(
				sound.src, //url to load
				this._playAfterLoad,//complete callback
				null,//progress callback
				0,//priority
				sound//the sound object (contains properties for PreloadJS/SoundJS)
			);
			return inst;
		}
		else if (loadState == LoadStates.loading)
		{
			//tell the sound to play after loading
			sound.playAfterLoad = true;
			inst = this._getSoundInst(null, sound.id);
			inst.curVol = volume;
			sound.waitingToPlay.push(inst);
			inst._endCallback = completeCallback;
			inst._startFunc = startCallback;
			if (inst._startParams)
			{
				arr = inst._startParams;
				arr[0] = interrupt;
				arr[1] = delay;
				arr[2] = offset;
				arr[3] = loop;
				arr[4] = pan;
			}
			else
				inst._startParams = [interrupt, delay, offset, loop, pan];
			return inst;
		}
	};

	/**
	*  Gets a SoundInstance, from the pool if available or maks a new one if not.
	*  @method _getSoundInst
	*  @private
	*  @param {createjs.SoundInstance} channel A createjs SoundInstance to initialize the object
	*                                          with.
	*  @param {String} id The alias of the sound that is going to be used.
	*  @return {SoundInstance} The SoundInstance that is ready to use.
	*/
	p._getSoundInst = function(channel, id)
	{
		var rtn;
		if (this._pool.length)
			rtn = this._pool.pop();
		else
		{
			rtn = new SoundInstance();
			rtn._endFunc = this._onSoundComplete.bind(this, rtn);
		}
		rtn._channel = channel;
		rtn.alias = id;
		rtn.length = channel ? channel.getDuration() : 0;//set or reset this
		rtn.isValid = true;
		return rtn;
	};

	/**
	*	Plays a sound after it finishes loading.
	*	@method _playAfterload
	*	@private
	*	@param {String} alias The sound to play.
	*/
	p._playAfterLoad = function(result)
	{
		var alias = typeof result == &quot;string&quot; ? result : result.id;
		var sound = this._sounds[alias];
		sound.loadState = LoadStates.loaded;

		//If the sound was stopped before it finished loading, then don&#x27;t play anything
		if (!sound.playAfterLoad) return;

		//Go through the list of sound instances that are waiting to start and start them
		var waiting = sound.waitingToPlay;

		var inst, startParams, volume, channel;
		for (var i = 0, len = waiting.length; i &lt; len; ++i)
		{
			inst = waiting[i];
			startParams = inst._startParams;
			volume = inst.curVol;
			channel = SoundJS.play(alias, startParams[0], startParams[1], startParams[2],
									startParams[3], volume, startParams[4]);

			if (!channel || channel.playState == SoundJS.PLAY_FAILED)
			{
				if (inst._endCallback)
					inst._endCallback();
				this._poolInst(inst);
			}
			else
			{
				sound.playing.push(inst);
				inst._channel = channel;
				if (channel.handleExtraData)
					channel.handleExtraData(sound.data);
				inst.length = channel.getDuration();
				if(!sound.duration)
					sound.duration = inst.length;
				inst.updateVolume();
				channel.addEventListener(&quot;complete&quot;, inst._endFunc);
				if (inst._startFunc)
					inst._startFunc();
				if (inst.paused)//if the sound got paused while loading, then pause it
					channel.pause();
			}
		}
		waiting.length = 0;
	};

	/**
	*	The callback used for when a sound instance is complete.
	*	@method _onSoundComplete
	*	@private
	*	@param {SoundInstance} inst The SoundInstance that is complete.s
	*/
	p._onSoundComplete = function(inst)
	{
		if (inst._channel)
		{
			inst._channel.removeEventListener(&quot;complete&quot;, inst._endFunc);
			var sound = this._sounds[inst.alias];
			var index = sound.playing.indexOf(inst);
			if (index &gt; -1)
				sound.playing.splice(index, 1);
			var callback = inst._endCallback;
			this._poolInst(inst);
			if (callback)
				callback();
		}
	};

	/**
	*	Stops all playing or loading instances of a given sound.
	*	@method stop
	*	@public
	*	@param {String} alias The alias of the sound to stop.
	*/
	p.stop = function(alias)
	{
		var s = this._sounds[alias];
		if (!s) return;
		if (s.playing.length)
			this._stopSound(s);
		else if (s.loadState == LoadStates.loading)
		{
			s.playAfterLoad = false;
			var waiting = s.waitingToPlay;
			var inst;
			for (var i = 0, len = waiting.length; i &lt; len; ++i)
			{
				inst = waiting[i];
				this._poolInst(inst);
			}
			waiting.length = 0;
		}
	};

	/**
	*	Stops all playing SoundInstances for a sound.
	*	@method _stopSound
	*	@private
	*	@param {Object} s The sound (from the _sounds dictionary) to stop.
	*/
	p._stopSound = function(s)
	{
		var arr = s.playing;
		for (var i = arr.length -1; i &gt;= 0; --i)
		{
			this._stopInst(arr[i]);
		}
		arr.length = 0;
	};

	/**
	*	Stops and repools a specific SoundInstance.
	*	@method _stopInst
	*	@private
	*	@param {SoundInstance} inst The SoundInstance to stop.
	*/
	p._stopInst = function(inst)
	{
		if (inst._channel)
		{
			inst._channel.removeEventListener(&quot;complete&quot;, inst._endFunc);
			inst._channel.stop();
		}
		this._poolInst(inst);
	};

	/**
	*	Stops all sounds in a given context.
	*	@method stopContext
	*	@public
	*	@param {String} context The name of the context to stop.
	*/
	p.stopContext = function(context)
	{
		context = this._contexts[context];
		if (context)
		{
			var arr = context.sounds;
			var s;
			for (var i = arr.length - 1; i &gt;= 0; --i)
			{
				s = arr[i];
				if (s.playing.length)
					this._stopSound(s);
				else if (s.loadState == LoadStates.loading)
					s.playAfterLoad = false;
			}
		}
	};

	/**
	 * Stop all sounds that are playing, regardless of context.
	 * @method stopAll
	 */
	p.stopAll = function()
	{
		for(var alias in this._sounds)
		{
			this.stop(alias);
		}
	};

	/**
	*	Pauses a specific sound.
	*	@method pauseSound
	*	@public
	*	@param {String} alias The alias of the sound to pause.
	*		Internally, this can also be the object from the _sounds dictionary directly.
	*/
	p.pauseSound = function(alias)
	{
		var sound;
		if (typeof alias == &quot;string&quot;)
			sound = this._sounds[alias];
		else
			sound = alias;
		var arr = sound.playing;
		for (var i = arr.length - 1; i &gt;= 0; --i)
			arr[i].pause();
	};

	/**
	*	Unpauses a specific sound.
	*	@method unpauseSound
	*	@public
	*	@param {String} alias The alias of the sound to pause.
	*		Internally, this can also be the object from the _sounds dictionary directly.
	*/
	p.unpauseSound = function(alias)
	{
		var sound;
		if (typeof alias == &quot;string&quot;)
			sound = this._sounds[alias];
		else
			sound = alias;
		var arr = sound.playing;
		for (var i = arr.length - 1; i &gt;= 0; --i)
		{
			arr[i].unpause();
		}
	};

	/**
	*	Pauses all sounds.
	*	@method pauseAll
	*	@public
	*/
	p.pauseAll = function()
	{
		var arr = this._sounds;
		for (var i in arr)
			this.pauseSound(arr[i]);
	};

	/**
	*	Unpauses all sounds.
	*	@method unpauseAll
	*	@public
	*/
	p.unpauseAll = function()
	{
		var arr = this._sounds;
		for (var i in arr)
			this.unpauseSound(arr[i]);
	};

	/**
	*	Sets mute status of all sounds in a context
	*	@method setContextMute
	*	@public
	*	@param {String} context The name of the context to modify.
	*	@param {Boolean} muted If the context should be muted.
	*/
	p.setContextMute = function(context, muted)
	{
		context = this._contexts[context];
		if (context)
		{
			context.muted = muted;
			var volume = context.volume;
			var arr = context.sounds;

			var s, playing, j;
			for (var i = arr.length - 1; i &gt;= 0; --i)
			{
				s = arr[i];
				if (s.playing.length)
				{
					playing = s.playing;
					for (j = playing.length - 1; j &gt;= 0; --j)
					{
						playing[j].updateVolume(muted ? 0 : volume);
					}
				}
			}
		}
	};

	/**
	*  Set the mute status of all sounds
	*  @property {Boolean} muteAll
	*/
	Object.defineProperty(p, &#x27;muteAll&#x27;, {
		set: function(muted)
		{
			SoundJS.setMute(!!muted);
		}
	});

	/**
	*	Sets volume of a context. Individual sound volumes are multiplied by this value.
	*	@method setContextVolume
	*	@public
	*	@param {String} context The name of the context to modify.
	*	@param {Number} volume The volume for the context (0 to 1).
	*/
	p.setContextVolume = function(context, volume)
	{
		context = this._contexts[context];
		if (context)
		{
			var muted = context.muted;
			context.volume = volume;
			var arr = context.sounds;
			var s, playing, j;
			for (var i = arr.length - 1; i &gt;= 0; --i)
			{
				s = arr[i];
				if (s.playing.length)
				{
					playing = s.playing;
					for (j = playing.length - 1; j &gt;= 0; --j)
					{
						playing[j].updateVolume(muted ? 0 : volume);
					}
				}
			}
		}
	};

	/**
	*	Preloads a specific sound.
	*	@method preloadSound
	*	@public
	*	@param {String} alias The alias of the sound to load.
	*	@param {function} callback The function to call when the sound is finished loading.
	*/
	p.preloadSound = function(alias, callback)
	{
		var sound = this._sounds[alias];
		if (!sound)
		{
			if (DEBUG &amp;&amp; Debug) Debug.error(&quot;Sound does not exist: &quot; + alias + &quot; - can&#x27;t preload!&quot;);
			return;
		}
		if (sound.loadState != LoadStates.unloaded) return;
		sound.loadState = LoadStates.loading;
		sound.preloadCallback = callback || null;
		Loader.instance.load(
			sound.src, //url to load
			this._markLoaded,//complete callback
			null,//progress callback
			0,//priority
			sound//the sound object (contains properties for PreloadJS/SoundJS)
		);
	};

	/**
	*	Preloads a list of sounds.
	*	@method preload
	*	@public
	*	@param {Array} list An array of sound aliases to load.
	*	@param {function} callback The function to call when all sounds have been loaded.
	*/
	p.preload = function(list, callback)
	{
		if (!LoadTask || !TaskManager)
		{
			throw &quot;The Task Module is needed to preload audio!&quot;;
		}

		if (!list || list.length === 0)
		{
			if (callback)
				callback();
			return;
		}

		var tasks = [];
		var sound;
		for (var i = 0, len = list.length; i &lt; len; ++i)
		{
			sound = this._sounds[list[i]];
			if (sound)
			{
				if (sound.loadState == LoadStates.unloaded)
				{
					sound.loadState = LoadStates.loading;
					//sound is passed last so that SoundJS gets the sound ID
					tasks.push(new LoadTask(sound.id, sound.src, this._markLoaded, null, 0, sound));
				}
			}
			else
			{
				if (DEBUG &amp;&amp; Debug) Debug.error(&quot;springroll.Sound was asked to preload &quot; + list[i] + &quot; but it is not a registered sound!&quot;);
			}
		}
		if (tasks.length &gt; 0)
		{
			TaskManager.process(tasks, function()
			{
				if (callback)
					callback();
			});
		}
		else if (callback)
		{
			callback();
		}
	};

	/**
	*	Marks a sound as loaded. If it needs to play after the load, then it is played.
	*	@method _markLoaded
	*	@private
	*	@param {String} alias The alias of the sound to mark.
	*	@param {function} callback A function to call to show that the sound is loaded.
	*/
	p._markLoaded = function(result)
	{
		var alias = result.id;
		var sound = this._sounds[alias];
		if (sound)
		{
			
			sound.loadState = LoadStates.loaded;
			if (sound.playAfterLoad)
				this._playAfterLoad(alias);
		}
		var callback = sound.preloadCallback;
		if (callback)
		{
			sound.preloadCallback = null;
			callback();
		}
	};

	/**
	*	Creates a Task for the springroll Task library for preloading a list of sounds.
	*	This function will not work if the Task library was not loaded before the Sound library.
	*	@method createPreloadTask
	*	@public
	*	@param {String} id The id of the task.
	*	@param {Array} list An array of sound aliases to load.
	*	@param {function} callback The function to call when the task is complete.
	*	@return {springroll.Task} A task to load up all of the sounds in the list.
	*/
	p.createPreloadTask = function(id, list, callback)
	{
		if (!SoundListTask) return null;
		return new SoundListTask(id, list, callback);
	};

	/**
	*	Unloads a list of sounds to reclaim memory if possible.
	*	If the sounds are playing, they are stopped.
	*	@method unload
	*	@public
	*	@param {Array} list An array of sound aliases to unload.
	*/
	p.unload = function(list)
	{
		if (!list) return;

		var sound;
		for (var i = 0, len = list.length; i &lt; len; ++i)
		{
			sound = this._sounds[list[i]];
			if (sound)
			{
				this._stopSound(sound);
				sound.loadState = LoadStates.unloaded;
			}
			SoundJS.removeSound(list[i]);
		}
	};

	/**
	*	Places a SoundInstance back in the pool for reuse.
	*	@method _poolinst
	*	@private
	*	@param {SoundInstance} inst The instance to repool.
	*/
	p._poolInst = function(inst)
	{
		if (this._pool.indexOf(inst) == -1)
		{
			inst._endCallback = null;
			inst.alias = null;
			inst._channel = null;
			inst._startFunc = null;
			inst.curVol = 0;
			inst.paused = false;
			inst.isValid = false;
			this._pool.push(inst);
		}
	};

	/**
	*	Destroys springroll.Sound. This unloads loaded sounds in SoundJS.
	*	@method destroy
	*	@public
	*/
	p.destroy = function()
	{
		// Stop all sounds
		this.stopAll();

		// Remove all sounds from memeory
		SoundJS.removeAllSounds();

		// Remove the SWF from the page
		if (FlashAudioPlugin &amp;&amp; SoundJS.activePlugin instanceof FlashAudioPlugin)
		{
			var swf = document.getElementById(&quot;SoundJSFlashContainer&quot;);
			if (swf &amp;&amp; swf.parentNode)
			{
				swf.parentNode.removeChild(swf);
			}
		}
		if (Application.instance)
		{
			Application.instance.off(&#x27;paused&#x27;, this.pauseAll);
			Application.instance.off(&#x27;resumed&#x27;, this.unpauseAll);
			Application.instance.off(&#x27;destroy&#x27;, this.destroy);
		}

		_instance = null;

		this._sounds = null;
		this._volumes = null;
		this._fades = null;
		this._contexts = null;
		this._pool = null;
	};

	namespace(&#x27;springroll&#x27;).Sound = Sound;
}());
</pre>
</div>        </div>
      </div>
    </div>
  </div>
  <script src='../assets/js/libraries.js?v=0.2.0'></script>
  <script src='../assets/js/main.js?v=0.2.0'></script>
</body>
</html>